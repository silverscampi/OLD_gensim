// ----------------------------------------------------------------------------
// C4.6.1			Advanced SIMD across lanes
// ----------------------------------------------------------------------------

execute(saddlv)
{
	not_implemented();
}

execute(sminv)
{
	switch (inst.arrangement) {
	case 0: {	// 8b
		sint8[8] rn = read_register_bank(VB8B, inst.rn);

		sint8 min = rn[0];
		for (uint8 i = 1; i < 8; i++) {
			if (rn[i] < min) {
				min = rn[i];
			}
		}

		write_vector_reg8(inst.rd, min);
		break;
	}
	case 1: {	// 16b
		sint8[16] rn = read_register_bank(VB16B, inst.rn);

		sint8 min = rn[0];
		for (uint8 i = 1; i < 16; i++) {
			if (rn[i] < min) {
				min = rn[i];
			}
		}

		write_vector_reg8(inst.rd, min);
		break;
	}
	case 2: {	// 4h
		sint16[4] rn = read_register_bank(VB4H, inst.rn);

		sint16 min = rn[0];
		for (uint8 i = 1; i < 4; i++) {
			if (rn[i] < min) {
				min = rn[i];
			}
		}

		write_vector_reg16(inst.rd, min);
		break;
	}
	case 3: {	// 8h
		sint16[8] rn = read_register_bank(VB8H, inst.rn);

		sint16 min = rn[0];
		for (uint8 i = 1; i < 8; i++) {
			if (rn[i] < min) {
				min = rn[i];
			}
		}

		write_vector_reg16(inst.rd, min);
		break;
	}
	case 5: {	// 4s
		sint32[4] rn = read_register_bank(VB4S, inst.rn);

		sint32 min = rn[0];
		for (uint8 i = 1; i < 4; i++) {
			if (rn[i] < min) {
				min = rn[i];
			}
		}

		write_vector_reg32(inst.rd, min);
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(smaxv)
{
	switch (inst.arrangement) {
	case 0: {	// 8b
		sint8[8] rn = read_register_bank(VB8B, inst.rn);

		sint8 min = rn[0];
		for (uint8 i = 1; i < 8; i++) {
			if (rn[i] > min) {
				min = rn[i];
			}
		}

		write_vector_reg8(inst.rd, min);
		break;
	}
	case 1: {	// 16b
		sint8[16] rn = read_register_bank(VB16B, inst.rn);

		sint8 min = rn[0];
		for (uint8 i = 1; i < 16; i++) {
			if (rn[i] > min) {
				min = rn[i];
			}
		}

		write_vector_reg8(inst.rd, min);
		break;
	}
	case 2: {	// 4h
		sint16[4] rn = read_register_bank(VB4H, inst.rn);

		sint16 min = rn[0];
		for (uint8 i = 1; i < 4; i++) {
			if (rn[i] > min) {
				min = rn[i];
			}
		}

		write_vector_reg16(inst.rd, min);
		break;
	}
	case 3: {	// 8h
		sint16[8] rn = read_register_bank(VB8H, inst.rn);

		sint16 min = rn[0];
		for (uint8 i = 1; i < 8; i++) {
			if (rn[i] > min) {
				min = rn[i];
			}
		}

		write_vector_reg16(inst.rd, min);
		break;
	}
	case 5: {	// 4s
		sint32[4] rn = read_register_bank(VB4S, inst.rn);

		sint32 min = rn[0];
		for (uint8 i = 1; i < 4; i++) {
			if (rn[i] > min) {
				min = rn[i];
			}
		}

		write_vector_reg32(inst.rd, min);
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(addv)
{
	uint64 total = 0;
	
	switch (inst.arrangement) {
	case 0: {	// 8b
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		
		for (uint8 i = 0; i < 8; i++) {
			total += rn[i];
		}
		break;
	}
	case 1: {	// 16b
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		
		for (uint8 i = 0; i < 16; i++) {
			total += rn[i];
		}
		break;
	}
	case 2: {	// 4h
		uint16[4] rn = read_register_bank(VB4H, inst.rn);
		
		for (uint8 i = 0; i < 4; i++) {
			total += rn[i];
		}
		break;
	}
	case 3: {	// 8h
		uint16[8] rn = read_register_bank(VB8H, inst.rn);
		
		for (uint8 i = 0; i < 8; i++) {
			total += rn[i];
		}
		break;
	}
	case 4: {	// 2s
		trap();
		break;
	}
	case 5: {	// 4s
		uint32[4] rn = read_register_bank(VB4S, inst.rn);
		
		for (uint8 i = 0; i < 4; i++) {
			total += rn[i];
		}
		break;
	}
	case 6: {	// 2d
		trap();
		break;
	}
	default: {
		trap();
		break;
	}
	}
	
	switch (inst.size) {
	case 0: {
		write_vector_reg8(inst.rd, (uint8)total);
		break;
	}
	case 1: {
		write_vector_reg16(inst.rd, (uint16)total);
		break;
	}
	case 2: {
		write_vector_reg32(inst.rd, (uint32)total);
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(uaddlv)
{
	not_implemented();
}

execute(umaxv)
{
	not_implemented();
}

execute(uminv)
{
	switch (inst.arrangement) {
	case 0: {	// 8b
		uint8[8] rn = read_register_bank(VB8B, inst.rn);

		uint8 min = rn[0];
		for (uint8 i = 1; i < 8; i++) {
			if (rn[i] < min) {
				min = rn[i];
			}
		}

		write_vector_reg8(inst.rd, min);
		break;
	}
	case 1: {	// 16b
		uint8[16] rn = read_register_bank(VB16B, inst.rn);

		uint8 min = rn[0];
		for (uint8 i = 1; i < 16; i++) {
			if (rn[i] < min) {
				min = rn[i];
			}
		}

		write_vector_reg8(inst.rd, min);
		break;
	}
	case 2: {	// 4h
		uint16[4] rn = read_register_bank(VB4H, inst.rn);

		uint16 min = rn[0];
		for (uint8 i = 1; i < 4; i++) {
			if (rn[i] < min) {
				min = rn[i];
			}
		}

		write_vector_reg16(inst.rd, min);
		break;
	}
	case 3: {	// 8h
		uint16[8] rn = read_register_bank(VB8H, inst.rn);

		uint16 min = rn[0];
		for (uint8 i = 1; i < 8; i++) {
			if (rn[i] < min) {
				min = rn[i];
			}
		}

		write_vector_reg16(inst.rd, min);
		break;
	}
	case 5: {	// 4s
		uint32[4] rn = read_register_bank(VB4S, inst.rn);

		uint32 min = rn[0];
		for (uint8 i = 1; i < 4; i++) {
			if (rn[i] < min) {
				min = rn[i];
			}
		}

		write_vector_reg32(inst.rd, min);
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(fmaxnmv)
{
	not_implemented();
}

execute(fmaxv)
{
	not_implemented();
}

execute(fminnmv)
{
	not_implemented();
}

execute(fminv)
{
	not_implemented();
}

// ----------------------------------------------------------------------------
// C4.6.1			Advanced SIMD across lanes
// ----------------------------------------------------------------------------
execute(dup_elem)
{
	switch (inst.arrangement) {
	case 0: {	// 8B
		uint8[8] src = read_register_bank(VB8B, inst.rn);
		uint8[8] dst = (uint8)0;
		
		uint8 v = src[inst.eindex];
		for (uint8 i = 0; i < 8; i++) {
			dst[i] = v;
		}
		
		write_register_bank(VB8B, inst.rd, dst);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 1: {	// 16B
		uint8[16] src = read_register_bank(VB16B, inst.rn);
		uint8[16] dst = (uint8)0;
		
		uint8 v = src[inst.eindex];
		for (uint8 i = 0; i < 16; i++) {
			dst[i] = v;
		}
		
		write_register_bank(VB16B, inst.rd, dst);		
		break;
	}
	case 2: {	// 4H
		uint16[4] src = read_register_bank(VB4H, inst.rn);
		uint16[4] dst = (uint16)0;
		
		uint16 v = src[inst.eindex];
		for (uint8 i = 0; i < 4; i++) {
			dst[i] = v;
		}
		
		write_register_bank(VB4H, inst.rd, dst);		
		write_register_bank(VBH, inst.rd, 0);
		break;
	}
	case 3: {	// 8H
		uint16[8] src = read_register_bank(VB8H, inst.rn);
		uint16[8] dst = (uint16)0;
		
		uint16 v = src[inst.eindex];
		for (uint8 i = 0; i < 8; i++) {
			dst[i] = v;
		}
		
		write_register_bank(VB8H, inst.rd, dst);		
		break;
	}
	case 4: {	// 2S
		uint32[2] src = read_register_bank(VB2S, inst.rn);
		uint32[2] dst = (uint32)0;
		
		uint32 v = src[inst.eindex];
		for (uint8 i = 0; i < 2; i++) {
			dst[i] = v;
		}
		
		write_register_bank(VB2S, inst.rd, dst);		
		write_register_bank(VBH, inst.rd, 0);
		break;
	}
	case 5: {	// 4S
		uint32[4] src = read_register_bank(VB4S, inst.rn);
		uint32[4] dst = (uint32)0;
		
		uint32 v = src[inst.eindex];
		for (uint8 i = 0; i < 4; i++) {
			dst[i] = v;
		}
		
		write_register_bank(VB4S, inst.rd, dst);		
		break;
	}
	case 6: {	// 2D
		uint64[2] src = read_register_bank(VB2D, inst.rn);
		uint64[2] dst = (uint64)0;
		
		uint64 v = src[inst.eindex];
		for (uint8 i = 0; i < 2; i++) {
			dst[i] = v;
		}
		
		write_register_bank(VB2D, inst.rd, dst);		
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(dup_gen)
{
	uint64 element = read_gpr(inst.width==64, inst.rn);
	
	uint64 rlo;
	switch (inst.arrangement) {
	case 0: {	// 8B
		element &= 0xff;
		rlo = element | (element << 8) | (element << 16) | (element << 24) | (element << 32) | (element << 40) | (element << 48) | (element << 56);
		break;
	}
	case 1: {	// 16B
		element &= 0xff;
		rlo = element | (element << 8) | (element << 16) | (element << 24) | (element << 32) | (element << 40) | (element << 48) | (element << 56);
		break;
	}
	case 2: {	// 4H
		element &= 0xffff;
		rlo = element | (element << 16) | (element << 32) | (element << 48);
		break;
	}
	case 3: {	// 8H
		element &= 0xffff;
		rlo = element | (element << 16) | (element << 32) | (element << 48);
		break;
	}
	case 4: {	// 2S
		element &= 0xffffffff;
		rlo = element | (element << 32);
		break;
	}
	case 5: {	// 4S
		element &= 0xffffffff;
		rlo = element | (element << 32);
		break;
	}
	case 6: {	// 2D
		rlo = element;
		break;
	}
	default: {
		trap();
		break;
	}
	}
	
	if (inst.Q == 1) {
		write_vector_reg128(inst.rd, rlo, rlo);
	} else {
		write_vector_reg64(inst.rd, rlo);
	}
}

execute(smov)
{
	not_implemented();
}

execute(umov)
{
	// arrg, width, sz
	uint8 index = (inst.imm5 & 0x1f) >> (inst.size+1);

	uint64 rnl;
	uint64 rnh;
	read_vector_reg128(inst.rn, rnl, rnh);
		
	uint64 value;
	switch (inst.size) {
	case 0: {
		if (index < 8) {
			/*uint8[8] v;
			v = read_register_bank(VB8L, inst.rn);
			value = (uint64)v[index];*/
		
			value = rnl >> (index * 8);
		} else {
			value = rnh >> ((index - 8) * 8);
		}
		value &= 0xff;
		break;
	}
	case 1: {
		if (index < 4) {
			value = rnl >> (index * 16);
		} else {
			value = rnh >> ((index - 4) * 16);
		}
		value &= 0xffff;
		break;
	}
	case 2: {
		if (index < 2) {
			value = rnl >> (index * 32);
		} else {
			value = rnh >> ((index - 2) * 32);
		}
		value &= 0xffffffff;
		break;
	}
	case 3: {
		if (index == 0) {
			value = rnl+0;
		} else {
			value = rnh+0;
		}
		break;
	}
	}
	
	write_gpr(inst.width == 64, inst.rd, value);
}

execute(ins_gen)
{
	if ((inst.imm5 & 1) == 1) {
		// B
		uint8[16] rd = read_register_bank(VB16B, inst.rd);
		rd[(inst.imm5 >> 1) & 0xf] = read_gpr32(inst.rn);
		write_register_bank(VB16B, inst.rd, rd);
	} else if ((inst.imm5 & 3) == 2) {
		// H
		uint16[8] rd = read_register_bank(VB8H, inst.rd);
		rd[(inst.imm5 >> 2) & 0x7] = read_gpr32(inst.rn);
		write_register_bank(VB8H, inst.rd, rd);
	} else if ((inst.imm5 & 7) == 4) {
		// S
		uint32[4] rd = read_register_bank(VB4S, inst.rd);
		rd[(inst.imm5 >> 3) & 0x3] = read_gpr32(inst.rn);
		write_register_bank(VB4S, inst.rd, rd);
	} else if ((inst.imm5 & 0xf) == 8) {
		// D
		uint64[2] rd = read_register_bank(VB2D, inst.rd);
		rd[(inst.imm5 >> 4) & 0x1] = read_gpr64(inst.rn);
		write_register_bank(VB2D, inst.rd, rd);
	} else {
		not_implemented();
	}
}

execute(ins_elem)
{
	// size, eindex
	
	switch (inst.size) {
		case 0:	{ // b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint8[16] rd = read_register_bank(VB16B, inst.rd);
			
			rd[inst.eindex] = rn[inst.eindex2];
			
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 1:	{ // h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint16[8] rd = read_register_bank(VB8H, inst.rd);
			
			rd[inst.eindex] = rn[inst.eindex2];
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 2:	{ // s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint32[4] rd = read_register_bank(VB4S, inst.rd);
			
			rd[inst.eindex] = rn[inst.eindex2];
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 3:	{ // d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			uint64[2] rd = read_register_bank(VB2D, inst.rd);
			
			rd[inst.eindex] = rn[inst.eindex2];
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
	}
}

execute(rev32_simd)
{
	switch (inst.arrangement) {
		case 0: {	// 8B
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			
			rn[0] = __builtin_bswap32(rn[0]);
			rn[1] = __builtin_bswap32(rn[1]);
			
			write_register_bank(VB2S, inst.rd, rn);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 1: {	// 16B
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			
			rn[0] = __builtin_bswap32(rn[0]);
			rn[1] = __builtin_bswap32(rn[1]);
			rn[2] = __builtin_bswap32(rn[2]);
			rn[3] = __builtin_bswap32(rn[3]);
			
			write_register_bank(VB4S, inst.rd, rn);
			break;
		}
		case 2: {	// 4H
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			
			rn[0] = rn[0] >>> 16;
			rn[1] = rn[1] >>> 16;
			
			write_register_bank(VB2S, inst.rd, rn);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 3: {	// 8H
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			
			rn[0] = rn[0] >>> 16;
			rn[1] = rn[1] >>> 16;
			rn[2] = rn[2] >>> 16;
			rn[3] = rn[3] >>> 16;
			
			write_register_bank(VB4S, inst.rd, rn);
			break;
		}
		default: {
			trap();
			break;
		}
	}
}

execute(rev64_simd)
{
	switch (inst.arrangement) {
		case 0: {	// 8B
			uint64 rn = read_register_bank(VBL, inst.rn);
			rn = __builtin_bswap64(rn);
			
			write_register_bank(VBL, inst.rd, rn);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 1: {	// 16B
			uint64[2] rn = read_register_bank(VB2D, inst.rn);			
			rn[0] = __builtin_bswap64(rn[0]);
			rn[1] = __builtin_bswap64(rn[1]);
			
			write_register_bank(VB2D, inst.rd, rn);
			break;
		}
		case 2: {	// 4H
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			
			uint16[4] rd = 0;
			rd[0] = rn[3];
			rd[1] = rn[2];
			rd[2] = rn[1];
			rd[3] = rn[0];
			
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 3: {	// 8H
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			
			uint16[8] rd = 0;
			rd[0] = rn[3];
			rd[1] = rn[2];
			rd[2] = rn[1];
			rd[3] = rn[0];
			rd[4] = rn[7];
			rd[5] = rn[6];
			rd[6] = rn[5];
			rd[7] = rn[4];
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: {	// 2S
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			
			uint32[2] rd = 0;
			rd[0] = rn[1];
			rd[1] = rn[0];
			
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 5: {	// 4S
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			
			uint32[4] rd = 0;
			rd[0] = rn[1];
			rd[1] = rn[0];
			rd[2] = rn[3];
			rd[3] = rn[2];
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
	}
}

helper void store_vector_pair(uint8 size, uint8 rt1, uint8 rt2, uint64 addr)
{
	uint8 offset = 1 << size;
	store_vector(size, rt1, addr);
	store_vector(size, rt2, addr+offset);
	return;
}

helper void load_vector_pair(uint8 size, uint8 rt1, uint8 rt2, uint64 addr)
{
	uint8 offset = 1 << size;
	load_vector(size, rt1, addr);
	load_vector(size, rt2, addr+offset);
	return;
}

execute(stp_simd)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	addr += inst.imms64;
	
	store_vector_pair(inst.opc+2, inst.rt, inst.rt2, addr);
}

execute(stpi_simd)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	if (inst.P) {
		addr += inst.immu64;
	}
	
	store_vector_pair(inst.opc + 2, inst.rt, inst.rt2, addr);
	
	if (!inst.P) {
		addr += inst.immu64;
	}
	
	write_gpr_sp(1, inst.rn, addr);
}

execute(ldp_simd)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	addr += inst.imms64;
	
	load_vector_pair(inst.opc + 2, inst.rt, inst.rt2, addr);
}

execute(ldpi_simd)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	if (inst.P) {
		addr += inst.immu64;
	}
	
	load_vector_pair(inst.opc + 2, inst.rt, inst.rt2, addr);
	
	if (!inst.P) {
		addr += inst.immu64;
	}
	
	write_gpr_sp(1, inst.rn, addr);
}

// ----------------------------------------------------------------------------
// C4.6.10			Advanced SIMD scalar three same
// C4.6.16			Advanced SIMD three same
// ----------------------------------------------------------------------------
execute(add_vector)
{
	if (inst.SCALAR == 1) {
		uint64 rn = read_vector_reg64(inst.rn);
		uint64 rm = read_vector_reg64(inst.rm);
		
		write_vector_reg64(inst.rd, rn + rm);
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			uint8[8] rd = rn + rm;
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			uint8[16] rd = rn + rm;
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 2: {	// 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			uint16[4] rd = rn + rm;
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 3: {	// 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			uint16[8] rd = rn + rm;
			write_register_bank(VB8H, inst.rd, rd);
			
			break;
		}
		case 4: {	// 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			uint32[2] rd = rn + rm;
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 5: {	// 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			uint32[4] rd = rn + rm;
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: {	// 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			uint64[2] rm = read_register_bank(VB2D, inst.rm);
			
			uint64[2] rd = rn + rm;
			write_register_bank(VB2D, inst.rd, rd);
			
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(sub_vector)
{
	if (inst.SCALAR == 1) {
		uint64 rn = read_vector_reg64(inst.rn);
		uint64 rm = read_vector_reg64(inst.rm);
		
		write_vector_reg64(inst.rd, rn - rm);
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			uint8[8] rd = rn - rm;
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			uint8[16] rd = rn - rm;
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 2: {	// 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			uint16[4] rd = rn - rm;
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 3: {	// 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			uint16[8] rd = rn - rm;
			write_register_bank(VB8H, inst.rd, rd);
			
			break;
		}
		case 4: {	// 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			uint32[2] rd = rn - rm;
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 5: {	// 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			uint32[4] rd = rn - rm;
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: {	// 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			uint64[2] rm = read_register_bank(VB2D, inst.rm);
			
			uint64[2] rd = rn - rm;
			write_register_bank(VB2D, inst.rd, rd);
			
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(addp_vector)
{
	switch (inst.arrangement) {
	case 0: {	// 8b
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		uint8[8] rm = read_register_bank(VB8B, inst.rm);
		
		uint8[8] rd = (uint8)0;
		for (uint8 ia = 0; ia < 4; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint8 ib = 0; ib < 4; ib++) {
			rd[ib+4] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB8B, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 1: {	// 16b
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		uint8[16] rm = read_register_bank(VB16B, inst.rm);
		
		uint8[16] rd = (uint8)0;
		for (uint16 ia = 0; ia < 8; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint16 ib = 0; ib < 8; ib++) {
			rd[ib+8] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB16B, inst.rd, rd);
		break;
	}
	case 2: {	// 4h
		uint16[4] rn = read_register_bank(VB4H, inst.rn);
		uint16[4] rm = read_register_bank(VB4H, inst.rm);
		
		uint16[4] rd = (uint16)0;
		for (uint8 ia = 0; ia < 2; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint8 ib = 0; ib < 2; ib++) {
			rd[ib+2] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB4H, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 3: {	// 8h
		uint16[8] rn = read_register_bank(VB8H, inst.rn);
		uint16[8] rm = read_register_bank(VB8H, inst.rm);
		
		uint16[8] rd = (uint16)0;
		for (uint8 ia = 0; ia < 4; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint8 ib = 0; ib < 4; ib++) {
			rd[ib+4] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		write_register_bank(VB8H, inst.rd, rd);
		
		break;
	}
	case 4: {	// 2s
		uint32[2] rn = read_register_bank(VB2S, inst.rn);
		uint32[2] rm = read_register_bank(VB2S, inst.rm);
		
		uint32[2] rd = (uint32)0;
		for (uint8 ia = 0; ia < 1; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint8 ib = 0; ib < 1; ib++) {
			rd[ib+1] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB2S, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 5: {	// 4s
		uint32[4] rn = read_register_bank(VB4S, inst.rn);
		uint32[4] rm = read_register_bank(VB4S, inst.rm);
		
		uint32[4] rd = (uint32)0;
		for (uint8 ia = 0; ia < 2; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint8 ib = 0; ib < 2; ib++) {
			rd[ib+2] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 6: {	// 2d
		uint64[2] rn = read_register_bank(VB2D, inst.rn);
		uint64[2] rm = read_register_bank(VB2D, inst.rm);
		
		uint64[2] rd = (uint64)0;
		for (uint8 ia = 0; ia < 1; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia *2)+1];
		}
		
		for (uint8 ib = 0; ib < 1; ib++) {
			rd[ib+1] = rm[ib*2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(addp_scalar)
{
	uint64[2] rn = read_register_bank(VB2D, inst.rn);
	write_vector_reg64(inst.rd, rn[0] + rn[1]);
}

execute(and_vector)
{
	if (inst.Q == 0) {
		write_vector_reg64(inst.rd, read_vector_reg64(inst.rn) & read_vector_reg64(inst.rm));
	} else {
		uint64 a1;
		uint64 b1;
		uint64 a2;
		uint64 b2;
		
		read_vector_reg128(inst.rn, a1, b1);
		read_vector_reg128(inst.rm, a2, b2);
		
		write_vector_reg128(inst.rd, a1 & a2, b1 & b2);
	}
}

execute(orr_vector)
{
	if (inst.Q == 0) {
		write_vector_reg64(inst.rd, read_vector_reg64(inst.rn) | read_vector_reg64(inst.rm));
	} else {
		uint64 a1;
		uint64 b1;
		uint64 a2;
		uint64 b2;
		
		read_vector_reg128(inst.rn, a1, b1);
		read_vector_reg128(inst.rm, a2, b2);
		
		write_vector_reg128(inst.rd, a1 | a2, b1 | b2);
	}
}

execute(eor_vector)
{
	if (inst.Q == 0) {
		write_vector_reg64(inst.rd, read_vector_reg64(inst.rn) ^ read_vector_reg64(inst.rm));
	} else {
		uint64 a1;
		uint64 b1;
		uint64 a2;
		uint64 b2;
		
		read_vector_reg128(inst.rn, a1, b1);
		read_vector_reg128(inst.rm, a2, b2);
		
		write_vector_reg128(inst.rd, a1 ^ a2, b1 ^ b2);
	}
}

execute(orn_vector)
{
	if (inst.Q == 0) {
		write_vector_reg64(inst.rd, read_vector_reg64(inst.rn) | ~read_vector_reg64(inst.rm));
	} else {
		uint64 a1;
		uint64 b1;
		uint64 a2;
		uint64 b2;
		
		read_vector_reg128(inst.rn, a1, b1);
		read_vector_reg128(inst.rm, a2, b2);
		
		write_vector_reg128(inst.rd, a1 | ~a2, b1 | ~b2);
	}
}

execute(bic_vector)
{
	if (inst.Q == 0) {
		write_vector_reg64(inst.rd, read_vector_reg64(inst.rn) & ~read_vector_reg64(inst.rm));
	} else {
		uint64 a1;
		uint64 b1;
		uint64 a2;
		uint64 b2;
		
		read_vector_reg128(inst.rn, a1, b1);
		read_vector_reg128(inst.rm, a2, b2);
		
		write_vector_reg128(inst.rd, a1 & ~a2, b1 & ~b2);
	}
}

execute(mul_vector)
{
	switch (inst.arrangement) {
	case 0: { // 8b
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		uint8[8] rm = read_register_bank(VB8B, inst.rm);
		uint8[8] rd = rn * rm;
		
		write_register_bank(VB8B, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		break;
	}
	case 1: { // 16b
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		uint8[16] rm = read_register_bank(VB16B, inst.rm);
		uint8[16] rd = rn * rm;
		
		write_register_bank(VB16B, inst.rd, rd);
		break;
	}
	case 2: { // 4h
		uint16[4] rn = read_register_bank(VB4H, inst.rn);
		uint16[4] rm = read_register_bank(VB4H, inst.rm);
		uint16[4] rd = rn * rm;
		
		write_register_bank(VB4H, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		break;
	}
	case 3: { // 8h
		uint16[8] rn = read_register_bank(VB8H, inst.rn);
		uint16[8] rm = read_register_bank(VB8H, inst.rm);
		uint16[8] rd = rn * rm;
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 4: { // 2s
		uint32[2] rn = read_register_bank(VB2S, inst.rn);
		uint32[2] rm = read_register_bank(VB2S, inst.rm);
		uint32[2] rd = rn * rm;
		
		write_register_bank(VB2S, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		break;
	}
	case 5: { // 4s
		uint32[4] rn = read_register_bank(VB4S, inst.rn);
		uint32[4] rm = read_register_bank(VB4S, inst.rm);
		uint32[4] rd = rn * rm;
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	}
}

execute(mla_vector)
{
	switch (inst.arrangement) {
	case 0: { // 8b
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		uint8[8] rm = read_register_bank(VB8B, inst.rm);
		uint8[8] rd = read_register_bank(VB8B, inst.rd);
		
		rd += rn * rm;
		
		write_register_bank(VB8B, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		break;
	}
	case 1: { // 16b
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		uint8[16] rm = read_register_bank(VB16B, inst.rm);
		uint8[16] rd = read_register_bank(VB16B, inst.rd);
		
		rd += rn * rm;
		
		write_register_bank(VB16B, inst.rd, rd);
		break;
	}
	case 2: { // 4h
		uint16[4] rn = read_register_bank(VB4H, inst.rn);
		uint16[4] rm = read_register_bank(VB4H, inst.rm);
		uint16[4] rd = read_register_bank(VB4H, inst.rd);
		
		rd += rn * rm;
		
		write_register_bank(VB4H, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		break;
	}
	case 3: { // 8h
		uint16[8] rn = read_register_bank(VB8H, inst.rn);
		uint16[8] rm = read_register_bank(VB8H, inst.rm);
		uint16[8] rd = read_register_bank(VB8H, inst.rd);
		
		rd += rn * rm;
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 4: { // 2s
		uint32[2] rn = read_register_bank(VB2S, inst.rn);
		uint32[2] rm = read_register_bank(VB2S, inst.rm);
		uint32[2] rd = read_register_bank(VB2S, inst.rd);
		
		rd += rn * rm;
		
		write_register_bank(VB2S, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		break;
	}
	case 5: { // 4s
		uint32[4] rn = read_register_bank(VB4S, inst.rn);
		uint32[4] rm = read_register_bank(VB4S, inst.rm);
		uint32[4] rd = read_register_bank(VB4S, inst.rd);
		
		rd += rn * rm;
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	}
}

execute(mul_idx_vector)
{
	switch (inst.arrangement) {
	case 2: { // 4h
		uint16[4] rn = read_register_bank(VB4H, inst.rn);
		uint16[8] rm = read_register_bank(VB8H, inst.rmr);
		uint16[4] rd = rn * rm[inst.eindex];
		
		write_register_bank(VB4H, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		break;
	}
	case 3: { // 8h
		uint16[8] rn = read_register_bank(VB8H, inst.rn);
		uint16[8] rm = read_register_bank(VB8H, inst.rmr);
		uint16[8] rd = rn * rm[inst.eindex];
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 4: { // 2s
		uint32[2] rn = read_register_bank(VB2S, inst.rn);
		uint32[4] rm = read_register_bank(VB4S, inst.rmr);
		uint32[2] rd = rn * rm[inst.eindex];
		
		write_register_bank(VB2S, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		break;
	}
	case 5: { // 4s
		uint32[4] rn = read_register_bank(VB4S, inst.rn);
		uint32[4] rm = read_register_bank(VB4S, inst.rmr);
		uint32[4] rd = rn * rm[inst.eindex];
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	}
}

execute(fmul_vector)
{
	switch (inst.Q) {
	case 0: {	// 2s
		float[2] rn = read_register_bank(VF2S, inst.rn);
		float[2] rm = read_register_bank(VF2S, inst.rm);
		
		float[2] rd = rn * rm;
		write_register_bank(VF2S, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 1: {
		switch (inst.size) {
		case 0: {	// 4s
			float[4] rn = read_register_bank(VF4S, inst.rn);
			float[4] rm = read_register_bank(VF4S, inst.rm);
			
			float[4] rd = rn * rm;
			write_register_bank(VF4S, inst.rd, rd);
			
			break;
		}
		case 1: {	// 2d
			double[2] rn = read_register_bank(VF2D, inst.rn);
			double[2] rm = read_register_bank(VF2D, inst.rm);
			
			double[2] rd = rn * rm;
			write_register_bank(VF2D, inst.rd, rd);			
			break;
		}
		}
		break;
	}
	}
}

execute(fsub_vector)
{
	switch (inst.Q) {
	case 0: {	// 2s
		float[2] rn = read_register_bank(VF2S, inst.rn);
		float[2] rm = read_register_bank(VF2S, inst.rm);
		
		float[2] rd = rn - rm;
		write_register_bank(VF2S, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 1: {
		switch (inst.size) {
		case 2: {	// 4s
			float[4] rn = read_register_bank(VF4S, inst.rn);
			float[4] rm = read_register_bank(VF4S, inst.rm);
			
			float[4] rd = rn - rm;
			write_register_bank(VF4S, inst.rd, rd);
			
			break;
		}
		case 3: {	// 2d
			double[2] rn = read_register_bank(VF2D, inst.rn);
			double[2] rm = read_register_bank(VF2D, inst.rm);
			
			double[2] rd = rn - rm;
			write_register_bank(VF2D, inst.rd, rd);			
			break;
		}
		}
		break;
	}
	}
}

execute(cmeq_reg)
{
	if (inst.SCALAR) {
		uint64 rn = read_vector_reg64(inst.rn);
		uint64 rm = read_vector_reg64(inst.rm);
		
		if (rn == rm) {
			write_vector_reg64(inst.rd, (uint64)0xffffffffffffffff);
		} else {
			write_vector_reg64(inst.rd, 0);
		}
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			uint8[8] rd = rn == rm;
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			uint8[16] rd = rn == rm;
			write_register_bank(VB16B, inst.rd, rd);
			
			break;
		}
		case 2: {	// 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			uint16[4] rd = rn == rm;
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 3: {	// 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			uint16[8] rd = rn == rm;
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: {	// 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			uint32[2] rd = rn == rm;
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 5: {	// 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			uint32[4] rd = rn == rm;
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: {	// 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			uint64[2] rm = read_register_bank(VB2D, inst.rm);
			
			uint64[2] rd = rn == rm;
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(cmhi_reg)
{
	if (inst.SCALAR) {
		uint64 rn = read_vector_reg64(inst.rn);
		uint64 rm = read_vector_reg64(inst.rm);
		
		if (rn > rm) {
			write_vector_reg64(inst.rd, (uint64)0xffffffffffffffff);
		} else {
			write_vector_reg64(inst.rd, 0);
		}
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			uint8[8] rd = rn > rm;
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			uint8[16] rd = rn > rm;
			write_register_bank(VB16B, inst.rd, rd);
			
			break;
		}
		case 2: {	// 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			uint16[4] rd = rn > rm;
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 3: {	// 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			uint16[8] rd = rn > rm;
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: {	// 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			uint32[2] rd = rn > rm;
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 5: {	// 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			uint32[4] rd = rn > rm;
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: {	// 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			uint64[2] rm = read_register_bank(VB2D, inst.rm);
			
			uint64[2] rd = rn > rm;
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(cmhs_reg)
{
	if (inst.SCALAR) {
		uint64 rn = read_vector_reg64(inst.rn);
		uint64 rm = read_vector_reg64(inst.rm);
		
		if (rn >= rm) {
			write_vector_reg64(inst.rd, (uint64)0xffffffffffffffff);
		} else {
			write_vector_reg64(inst.rd, 0);
		}
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			uint8[8] rd = rn >= rm;
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			uint8[16] rd = rn >= rm;
			write_register_bank(VB16B, inst.rd, rd);
			
			break;
		}
		case 2: {	// 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			uint16[4] rd = rn > rm;
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 3: {	// 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			uint16[8] rd = rn >= rm;
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: {	// 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			uint32[2] rd = rn >= rm;
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 5: {	// 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			uint32[4] rd = rn >= rm;
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: {	// 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			uint64[2] rm = read_register_bank(VB2D, inst.rm);
			
			uint64[2] rd = rn >= rm;
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(cmtst)
{
	if (inst.SCALAR) {
		uint64 rn = read_vector_reg64(inst.rn);
		uint64 rm = read_vector_reg64(inst.rm);
		
		if ((rn & rm) != 0) {
			write_vector_reg64(inst.rd, (uint64)0xffffffffffffffff);
		} else {
			write_vector_reg64(inst.rd, 0);
		}
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			uint8[8] rd = (rn & rm) != 0;
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			uint8[16] rd = (rn & rm) != 0;
			write_register_bank(VB16B, inst.rd, rd);
			
			break;
		}
		case 2: {	// 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			uint16[4] rd = (rn & rm) != 0;
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 3: {	// 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			uint16[8] rd = (rn & rm) != 0;
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: {	// 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			uint32[2] rd = (rn & rm) != 0;
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 5: {	// 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			uint32[4] rd = (rn & rm) != 0;
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: {	// 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			uint64[2] rm = read_register_bank(VB2D, inst.rm);
			
			uint64[2] rd = (rn & rm) != 0;
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(fabd)
{
	if (inst.SCALAR) {
		if (inst.size == 2) {
			float rn = read_float_reg32(inst.rn);
			float rm = read_float_reg32(inst.rm);
		
			write_float_reg32(inst.rd, float_abs(rn - rm));
		} else if (inst.size == 3) {
			double rn = read_float_reg64(inst.rn);
			double rm = read_float_reg64(inst.rm);
		
			write_float_reg64(inst.rd, double_abs(rn - rm));
		}
	} else {
		trap();
	}
}

execute(cmeq_zero)
{
	if (inst.SCALAR) {
		uint64 rn = read_vector_reg64(inst.rn);
		
		if (rn == 0) {
			write_vector_reg64(inst.rd, 0xffffffff);
		} else {
			write_vector_reg64(inst.rd, 0);
		}
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			
			uint8[8] rd = rn == (uint8)0;
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			
			uint8[16] rd = rn == (uint8)0;
			write_register_bank(VB16B, inst.rd, rd);
			
			break;
		}
		case 2: {	// 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			
			uint16[4] rd = rn == (uint16)0;
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 3: {	// 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			
			uint16[8] rd = rn == (uint16)0;
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: {	// 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			
			uint32[2] rd = rn == (uint32)0;
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 5: {	// 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			
			uint32[4] rd = rn == (uint32)0;
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: {	// 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			
			uint64[2] rd = rn == (uint64)0;
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(cmge_zero)
{
	if (inst.SCALAR) {
		uint64 rn = read_vector_reg64(inst.rn);
		
		if (inst.U == 1) {
			if ((sint64)rn >= (sint64)0) {
				write_vector_reg64(inst.rd, (uint64)0xffffffffffffffff);
			} else {
				write_vector_reg64(inst.rd, 0);
			}
		} else {
			if ((sint64)rn > (sint64)0) {
				write_vector_reg64(inst.rd, (uint64)0xffffffffffffffff);
			} else {
				write_vector_reg64(inst.rd, 0);
			}
		}
	} else {
		if (inst.U == 1) {
			switch (inst.arrangement) {
			case 0: {	// 8b
				sint8[8] rn = read_register_bank(VB8B, inst.rn);
				
				uint8[8] rd = rn >= (sint8)0;
				write_register_bank(VB8B, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 1: {	// 16b
				sint8[16] rn = read_register_bank(VB16B, inst.rn);
				
				uint8[16] rd = rn >= (sint8)0;
				write_register_bank(VB16B, inst.rd, rd);
				
				break;
			}
			case 2: {	// 4h
				sint16[4] rn = read_register_bank(VB4H, inst.rn);
				
				uint16[4] rd = rn >= (sint16)0;
				write_register_bank(VB4H, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 3: {	// 8h
				sint16[8] rn = read_register_bank(VB8H, inst.rn);
				
				uint16[8] rd = rn >= (sint16)0;
				
				write_register_bank(VB8H, inst.rd, rd);
				break;
			}
			case 4: {	// 2s
				sint32[2] rn = read_register_bank(VB2S, inst.rn);
				
				uint32[2] rd = rn >= (sint32)0;
				write_register_bank(VB2S, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 5: {	// 4s
				sint32[4] rn = read_register_bank(VB4S, inst.rn);
				
				uint32[4] rd = rn >= (sint32)0;
				
				write_register_bank(VB4S, inst.rd, rd);
				break;
			}
			case 6: {	// 2d
				sint64[2] rn = read_register_bank(VB2D, inst.rn);
				
				uint64[2] rd = rn >= (sint64)0;
				
				write_register_bank(VB2D, inst.rd, rd);
				break;
			}
			default: {
				trap();
				break;
			}
			}
		} else {
			switch (inst.arrangement) {
			case 0: {	// 8b
				sint8[8] rn = read_register_bank(VB8B, inst.rn);
				
				uint8[8] rd = rn > (sint8)0;
				write_register_bank(VB8B, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 1: {	// 16b
				sint8[16] rn = read_register_bank(VB16B, inst.rn);
				
				uint8[16] rd = rn > (sint8)0;
				write_register_bank(VB16B, inst.rd, rd);
				
				break;
			}
			case 2: {	// 4h
				sint16[4] rn = read_register_bank(VB4H, inst.rn);
				
				uint16[4] rd = rn > (sint16)0;
				write_register_bank(VB4H, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 3: {	// 8h
				sint16[8] rn = read_register_bank(VB8H, inst.rn);
				
				uint16[8] rd = rn > (sint16)0;
				
				write_register_bank(VB8H, inst.rd, rd);
				break;
			}
			case 4: {	// 2s
				sint32[2] rn = read_register_bank(VB2S, inst.rn);
				
				uint32[2] rd = rn > (sint32)0;
				write_register_bank(VB2S, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 5: {	// 4s
				sint32[4] rn = read_register_bank(VB4S, inst.rn);
				
				uint32[4] rd = rn > (sint32)0;
				
				write_register_bank(VB4S, inst.rd, rd);
				break;
			}
			case 6: {	// 2d
				sint64[2] rn = read_register_bank(VB2D, inst.rn);
				
				uint64[2] rd = rn > (sint64)0;
				
				write_register_bank(VB2D, inst.rd, rd);
				break;
			}
			default: {
				trap();
				break;
			}
			}
		}
	}
}

execute(cmlt_zero)
{
	if (inst.SCALAR) {
		uint64 rn = read_vector_reg64(inst.rn);
		
		if (inst.U == 1) {
			if ((sint64)rn <= (sint64)0) {
				write_vector_reg64(inst.rd, (uint64)0xffffffffffffffff);
			} else {
				write_vector_reg64(inst.rd, 0);
			}
		} else {
			if ((sint64)rn < (sint64)0) {
				write_vector_reg64(inst.rd, (uint64)0xffffffffffffffff);
			} else {
				write_vector_reg64(inst.rd, 0);
			}
		}
	} else {
		if (inst.U == 1) {
			switch (inst.arrangement) {
			case 0: {	// 8b
				sint8[8] rn = read_register_bank(VB8B, inst.rn);
				
				uint8[8] rd = rn <= (sint8)0;
				write_register_bank(VB8B, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 1: {	// 16b
				sint8[16] rn = read_register_bank(VB16B, inst.rn);
				
				uint8[16] rd = rn <= (sint8)0;
				write_register_bank(VB16B, inst.rd, rd);
				
				break;
			}
			case 2: {	// 4h
				sint16[4] rn = read_register_bank(VB4H, inst.rn);
				
				uint16[4] rd = rn <= (sint16)0;
				write_register_bank(VB4H, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 3: {	// 8h
				sint16[8] rn = read_register_bank(VB8H, inst.rn);
				
				uint16[8] rd = rn <= (sint16)0;
				
				write_register_bank(VB8H, inst.rd, rd);
				break;
			}
			case 4: {	// 2s
				sint32[2] rn = read_register_bank(VB2S, inst.rn);
				
				uint32[2] rd = rn <= (sint32)0;
				write_register_bank(VB2S, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 5: {	// 4s
				sint32[4] rn = read_register_bank(VB4S, inst.rn);
				
				uint32[4] rd = rn <= (sint32)0;
				
				write_register_bank(VB4S, inst.rd, rd);
				break;
			}
			case 6: {	// 2d
				sint64[2] rn = read_register_bank(VB2D, inst.rn);
				
				uint64[2] rd = rn <= (sint64)0;
				
				write_register_bank(VB2D, inst.rd, rd);
				break;
			}
			default: {
				trap();
				break;
			}
			}
		} else {
			switch (inst.arrangement) {
			case 0: {	// 8b
				sint8[8] rn = read_register_bank(VB8B, inst.rn);
				
				uint8[8] rd = rn < (sint8)0;
				write_register_bank(VB8B, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 1: {	// 16b
				sint8[16] rn = read_register_bank(VB16B, inst.rn);
				
				uint8[16] rd = rn < (sint8)0;
				write_register_bank(VB16B, inst.rd, rd);
				
				break;
			}
			case 2: {	// 4h
				sint16[4] rn = read_register_bank(VB4H, inst.rn);
				
				uint16[4] rd = rn < (sint16)0;
				write_register_bank(VB4H, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 3: {	// 8h
				sint16[8] rn = read_register_bank(VB8H, inst.rn);
				
				uint16[8] rd = rn < (sint16)0;
				
				write_register_bank(VB8H, inst.rd, rd);
				break;
			}
			case 4: {	// 2s
				sint32[2] rn = read_register_bank(VB2S, inst.rn);
				
				uint32[2] rd = rn < (sint32)0;
				write_register_bank(VB2S, inst.rd, rd);
				write_register_bank(VBH, inst.rd, 0);
				
				break;
			}
			case 5: {	// 4s
				sint32[4] rn = read_register_bank(VB4S, inst.rn);
				
				uint32[4] rd = rn < (sint32)0;
				
				write_register_bank(VB4S, inst.rd, rd);
				break;
			}
			case 6: {	// 2d
				sint64[2] rn = read_register_bank(VB2D, inst.rn);
				
				uint64[2] rd = rn < (sint64)0;
				
				write_register_bank(VB2D, inst.rd, rd);
				break;
			}
			default: {
				trap();
				break;
			}
			}
		}
	}
}

execute(fcmgt_zero)
{
	if (inst.size == 2) {
		float rn = read_float_reg32(inst.rn);
		if (rn > (float)0) {
			write_vector_reg32(inst.rd, 0xffffffff);
		} else {
			write_vector_reg32(inst.rd, 0);
		}
	} else {
		double rn = read_float_reg64(inst.rn);
		if (rn > (double)0) {
			write_vector_reg64(inst.rd, (uint64)0xffffffffffffffff);
		} else {
			write_vector_reg64(inst.rd, 0);
		}
	}
}

execute(cnt)
{
	if (inst.SCALAR) {
		trap();
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			
			uint8[8] rd = (uint8)0;
			for (uint8 i = 0; i < 8; i++) {
				rd[i] = (uint8)__builtin_popcount32(rn[i]);
			}
			
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			
			uint8[16] rd = (uint8)0;
			for (uint8 i = 0; i < 16; i++) {
				rd[i] = (uint8)__builtin_popcount32(rn[i]);
			}
			
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 2: {	// 4h
			trap();
			break;
		}
		case 3: {	// 8h
			trap();
			break;
		}
		case 4: {	// 2s
			trap();
			break;
		}
		case 5: {	// 4s
			trap();
			break;
		}
		case 6: {	// 2d
			trap();
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(xtn)
{
	switch (inst.arrangement) {
		case 0: {	// 8h -> 8b
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			
			uint8[16] rd = (uint8)0;
			rd[0] = (uint8)rn[0];
			rd[1] = (uint8)rn[1];
			rd[2] = (uint8)rn[2];
			rd[3] = (uint8)rn[3];
			rd[4] = (uint8)rn[4];
			rd[5] = (uint8)rn[5];
			rd[6] = (uint8)rn[6];
			rd[7] = (uint8)rn[7];
			
			write_register_bank(VB16B, inst.rd, rd);
			
			break;
		}
		case 1: {	// 8h -> 16b (upper)
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			
			uint8[16] rd = read_register_bank(VB16B, inst.rd);
			rd[8] = (uint8)rn[0];
			rd[9] = (uint8)rn[1];
			rd[10] = (uint8)rn[2];
			rd[11] = (uint8)rn[3];
			rd[12] = (uint8)rn[4];
			rd[13] = (uint8)rn[5];
			rd[14] = (uint8)rn[6];
			rd[15] = (uint8)rn[7];
			
			write_register_bank(VB16B, inst.rd, rd);
			
			break;
		}
		case 2: {	// 4s -> 4h
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			
			uint16[8] rd = (uint16)0;
			rd[0] = (uint16)rn[0];
			rd[1] = (uint16)rn[1];
			rd[2] = (uint16)rn[2];
			rd[3] = (uint16)rn[3];
			
			write_register_bank(VB8H, inst.rd, rd);
			
			break;
		}
		case 3: {	// 4s -> 8h (upper)
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			
			uint16[8] rd = read_register_bank(VB8H, inst.rd);
			rd[4] = (uint16)rn[0];
			rd[5] = (uint16)rn[1];
			rd[6] = (uint16)rn[2];
			rd[7] = (uint16)rn[3];
			
			write_register_bank(VB8H, inst.rd, rd);
			
			break;
		}
		case 4: {	// 2d -> 2s
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			
			uint32[4] rd = (uint32)0;
			rd[0] = (uint32)rn[0];
			rd[1] = (uint32)rn[1];
			
			write_register_bank(VB4S, inst.rd, rd);
			
			break;
		}
		case 5: {	// 2d -> 4s (upper)
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			
			uint32[4] rd = read_register_bank(VB4S, inst.rd);
			rd[2] = (uint32)rn[0];
			rd[3] = (uint32)rn[1];
			
			write_register_bank(VB4S, inst.rd, rd);
			
			break;
		}
		default: {
			trap();
			break;
		}
	}
}

execute(bsl)
{
	if (inst.Q) {
		uint64 vdl;
		uint64 vdh;
		uint64 vnl;
		uint64 vnh;
		uint64 vml;
		uint64 vmh;
		
		read_vector_reg128(inst.rd, vdl, vdh);
		read_vector_reg128(inst.rn, vnl, vnh);
		read_vector_reg128(inst.rm, vml, vmh);
		
		write_vector_reg128(inst.rd, vml ^ ((vml ^ vnl) & vdl), vmh ^ ((vmh ^ vnh) & vdh));
	} else {
		uint64 vd;
		uint64 vn;
		uint64 vm;
		
		vd = read_vector_reg64(inst.rd);
		vn = read_vector_reg64(inst.rn);
		vm = read_vector_reg64(inst.rm);
		
		write_vector_reg64(inst.rd, vm ^ ((vm ^ vn) & vd));
	}
}

execute(bit)
{
	if (inst.Q) {
		uint64 vdl;
		uint64 vdh;
		uint64 vnl;
		uint64 vnh;
		uint64 vml;
		uint64 vmh;
		
		read_vector_reg128(inst.rd, vdl, vdh);
		read_vector_reg128(inst.rn, vnl, vnh);
		read_vector_reg128(inst.rm, vml, vmh);
		
		write_vector_reg128(inst.rd, vdl ^ ((vdl ^ vnl) & vml), vdh ^ ((vdh ^ vnh) & vmh));
	} else {
		uint64 vd;
		uint64 vn;
		uint64 vm;
		
		vd = read_vector_reg64(inst.rd);
		vn = read_vector_reg64(inst.rn);
		vm = read_vector_reg64(inst.rm);
		
		write_vector_reg64(inst.rd, vd ^ ((vd ^ vn) & vm));
	}
}

execute(bif)
{
	if (inst.Q) {
		uint64 vdl;
		uint64 vdh;
		uint64 vnl;
		uint64 vnh;
		uint64 vml;
		uint64 vmh;
		
		read_vector_reg128(inst.rd, vdl, vdh);
		read_vector_reg128(inst.rn, vnl, vnh);
		read_vector_reg128(inst.rm, vml, vmh);
		
		write_vector_reg128(inst.rd, vdl ^ ((vdl ^ vnl) & (~vml)), vdh ^ ((vdh ^ vnh) & (~vmh)));
	} else {
		uint64 vd;
		uint64 vn;
		uint64 vm;
		
		vd = read_vector_reg64(inst.rd);
		vn = read_vector_reg64(inst.rn);
		vm = read_vector_reg64(inst.rm);
		
		write_vector_reg64(inst.rd, vd ^ ((vd ^ vn) & (~vm)));
	}
}

execute(ld1)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	for (uint8 rt = 0; rt < inst.regcnt; rt++) {
		write_vector_reg128(inst.rt + rt, 0, 0);
		for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
			load_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
}

execute(ld2)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	write_vector_reg128(inst.rt, 0, 0);
	write_vector_reg128(inst.rt+1, 0, 0);
	
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			load_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
}

execute(ld3)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	write_vector_reg128(inst.rt, 0, 0);
	write_vector_reg128(inst.rt+1, 0, 0);
	write_vector_reg128(inst.rt+2, 0, 0);
	
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			load_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
}

execute(ld4)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	write_vector_reg128(inst.rt, 0, 0);
	write_vector_reg128(inst.rt+1, 0, 0);
	write_vector_reg128(inst.rt+2, 0, 0);
	write_vector_reg128(inst.rt+3, 0, 0);
	
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			load_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
}

execute(st1)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	for (uint8 rt = 0; rt < inst.regcnt; rt++) {
		for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
			store_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
}

execute(st2)
{
	uint64 address = read_gpr_sp(1, inst.rn);
		
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			store_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
}

execute(st3)
{
	uint64 address = read_gpr_sp(1, inst.rn);
		
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			store_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
}

execute(st4)
{
	uint64 address = read_gpr_sp(1, inst.rn);
		
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			store_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
}

execute(ld1pi)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	for (uint8 rt = 0; rt < inst.regcnt; rt++) {
		write_vector_reg128(inst.rt + rt, 0, 0);
		for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
			load_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
	
	if (inst.rm != 31) {
		address = read_gpr_sp(1, inst.rn) + read_gpr64(inst.rm);
	}
	
	write_gpr_sp(1, inst.rn, address);
}

execute(ld2pi)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	write_vector_reg128(inst.rt, 0, 0);
	write_vector_reg128(inst.rt+1, 0, 0);
	
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			load_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
	
	if (inst.rm != 31) {
		address = read_gpr_sp(1, inst.rn) + read_gpr64(inst.rm);
	}
	
	write_gpr_sp(1, inst.rn, address);
}

execute(ld3pi)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	write_vector_reg128(inst.rt, 0, 0);
	write_vector_reg128(inst.rt+1, 0, 0);
	write_vector_reg128(inst.rt+2, 0, 0);
	
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			load_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
	
	if (inst.rm != 31) {
		address = read_gpr_sp(1, inst.rn) + read_gpr64(inst.rm);
	}
	
	write_gpr_sp(1, inst.rn, address);
}

execute(ld4pi)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	write_vector_reg128(inst.rt, 0, 0);
	write_vector_reg128(inst.rt+1, 0, 0);
	write_vector_reg128(inst.rt+2, 0, 0);
	write_vector_reg128(inst.rt+3, 0, 0);
	
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			load_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
	
	if (inst.rm != 31) {
		address = read_gpr_sp(1, inst.rn) + read_gpr64(inst.rm);
	}
	
	write_gpr_sp(1, inst.rn, address);
}

execute(st1pi)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	for (uint8 rt = 0; rt < inst.regcnt; rt++) {
		for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
			store_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
	
	if (inst.rm != 31) {
		address = read_gpr_sp(1, inst.rn) + read_gpr64(inst.rm);
	}
	
	write_gpr_sp(1, inst.rn, address);
}

execute(st2pi)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			store_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
	
	if (inst.rm != 31) {
		address = read_gpr_sp(1, inst.rn) + read_gpr64(inst.rm);
	}
	
	write_gpr_sp(1, inst.rn, address);
}

execute(st3pi)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			store_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
	
	if (inst.rm != 31) {
		address = read_gpr_sp(1, inst.rn) + read_gpr64(inst.rm);
	}
	
	write_gpr_sp(1, inst.rn, address);
}

execute(st4pi)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
		for (uint8 rt = 0; rt < inst.regcnt; rt++) {
			store_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
	
	if (inst.rm != 31) {
		address = read_gpr_sp(1, inst.rn) + read_gpr64(inst.rm);
	}
	
	write_gpr_sp(1, inst.rn, address);
}

execute(ld1r)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	
	switch (inst.size) {
	case 0: {	// 8/16b
		uint8 value;
		mem_read_8(Data, addr, value);
		
		if (inst.Q == 0) {
			uint8[8] rd = value;
			write_register_bank(VB8B, inst.rt, rd);
			write_register_bank(VBH, inst.rt, 0);
		} else {
			uint8[16] rd = value;
			write_register_bank(VB16B, inst.rt, rd);
		}
		break;
	}
	case 1: {	// 4/8h
		uint16 value;
		mem_read_16(Data, addr, value);
		
		if (inst.Q == 0) {
			uint16[4] rd = value;
			write_register_bank(VB4H, inst.rt, rd);
			write_register_bank(VBH, inst.rt, 0);
		} else {
			uint16[8] rd = value;
			write_register_bank(VB8H, inst.rt, rd);
		}
		break;
	}
	case 2: {	// 2/4s
		uint32 value;
		mem_read_32(Data, addr, value);
		
		if (inst.Q == 0) {
			uint32[2] rd = value;
			write_register_bank(VB2S, inst.rt, rd);
			write_register_bank(VBH, inst.rt, 0);
		} else {
			uint32[4] rd = value;
			write_register_bank(VB4S, inst.rt, rd);
		}
		break;
	}
	case 3: {	// 1/2d
		uint64 value;
		mem_read_64(Data, addr, value);
		
		if (inst.Q == 0) {
			write_register_bank(VBL, inst.rt, value);
			write_register_bank(VBH, inst.rt, 0);
		} else {
			uint64[2] rd = value;
			write_register_bank(VB2D, inst.rt, rd);
		}
		break;
	}
	}
}

execute(ld1s)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	
	switch (inst.opcode) {
	case 0: {
		uint8 value;
		mem_read_8(Data, addr, value);
		
		uint8[16] rt = read_register_bank(VB16B, inst.rt);
		rt[inst.eindex] = value;
		write_register_bank(VB16B, inst.rt, rt);
		break;
	}
	case 2: {
		uint16 value;
		mem_read_16(Data, addr, value);
		
		uint16[8] rt = read_register_bank(VB8H, inst.rt);
		rt[inst.eindex] = value;
		write_register_bank(VB8H, inst.rt, rt);
		break;
	}
	case 4: {
		if (inst.size == 0) {
			uint32 value;
			mem_read_32(Data, addr, value);
			
			uint32[4] rt = read_register_bank(VB4S, inst.rt);
			rt[inst.eindex] = value;
			write_register_bank(VB4S, inst.rt, rt);
		} else if (inst.size == 1) {
			uint64 value;
			mem_read_64(Data, addr, value);
			
			uint64[2] rt = read_register_bank(VB2D, inst.rt);
			rt[inst.eindex] = value;
			write_register_bank(VB2D, inst.rt, rt);
		}
		break;
	}
	}
}

execute(st1s)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	
	switch (inst.opcode) {
	case 0: {
		uint8[16] rt = read_register_bank(VB16B, inst.rt);
		mem_write_8(Data, addr, rt[inst.eindex]);
		break;
	}
	case 2: {
		uint16[8] rt = read_register_bank(VB8H, inst.rt);
		mem_write_16(Data, addr, rt[inst.eindex]);
		break;
	}
	case 4: {
		if (inst.size == 0) {
			uint32[4] rt = read_register_bank(VB4S, inst.rt);
			mem_write_32(Data, addr, rt[inst.eindex]);
		} else if (inst.size == 1) {
			uint64[2] rt = read_register_bank(VB2D, inst.rt);
			mem_write_64(Data, addr, rt[inst.eindex]);
		}
		break;
	}
	}
}

execute(st1spi)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	
	switch (inst.opcode) {
	case 0: {
		uint8[16] rt = read_register_bank(VB16B, inst.rt);
		mem_write_8(Data, addr, rt[inst.eindex]);
		addr += 1;
		break;
	}
	case 2: {
		uint16[8] rt = read_register_bank(VB8H, inst.rt);
		mem_write_16(Data, addr, rt[inst.eindex]);
		addr += 2;
		break;
	}
	case 4: {
		if (inst.size == 0) {
			uint32[4] rt = read_register_bank(VB4S, inst.rt);
			mem_write_32(Data, addr, rt[inst.eindex]);
			addr += 4;
		} else if (inst.size == 1) {
			uint64[2] rt = read_register_bank(VB2D, inst.rt);
			mem_write_64(Data, addr, rt[inst.eindex]);
			addr += 8;
		}
		break;
	}
	}
	
	if (inst.rm != 31) {
		addr = read_gpr_sp(1, inst.rn) + read_gpr64(inst.rm);
	}
	
	write_gpr_sp(1, inst.rn, addr);
}

execute(smax)
{
	switch (inst.arrangement) {
		case 0: {	// 8b
			sint8[8] rn = read_register_bank(VB8B, inst.rn);
			sint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			sint8[8] mask = rn > rm;
			sint8[8] rd = (rn & mask) | (rm & ~mask);
			
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			sint8[16] rn = read_register_bank(VB16B, inst.rn);
			sint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			sint8[16] mask = rn > rm;
			sint8[16] rd = (rn & mask) | (rm & ~mask);
			
			write_register_bank(VB16B, inst.rd, rd);		
			break;
		}
		case 2: {	// 4h
			sint16[4] rn = read_register_bank(VB4H, inst.rn);
			sint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			sint16[4] mask = rn > rm;
			sint16[4] rd = (rn & mask) | (rm & ~mask);
			
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 3: {	// 8h
			sint16[8] rn = read_register_bank(VB8H, inst.rn);
			sint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			sint16[8] mask = rn > rm;
			sint16[8] rd = (rn & mask) | (rm & ~mask);
			
			write_register_bank(VB8H, inst.rd, rd);	
			break;
		}
		case 4: {	// 2s
			sint32[2] rn = read_register_bank(VB2S, inst.rn);
			sint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			sint32[2] mask = rn > rm;
			sint32[2] rd = (rn & mask) | (rm & ~mask);
			
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 5: {	// 4s
			sint32[4] rn = read_register_bank(VB4S, inst.rn);
			sint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			sint32[4] mask = rn > rm;
			sint32[4] rd = (rn & mask) | (rm & ~mask);
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
	}
}

execute(smin)
{
	switch (inst.arrangement) {
		case 0: {	// 8b
			sint8[8] rn = read_register_bank(VB8B, inst.rn);
			sint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			sint8[8] mask = rn > rm;
			sint8[8] rd = (rn & ~mask) | (rm & mask);
			
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			sint8[16] rn = read_register_bank(VB16B, inst.rn);
			sint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			sint8[16] mask = rn > rm;
			sint8[16] rd = (rn & ~mask) | (rm & mask);
			
			write_register_bank(VB16B, inst.rd, rd);		
			break;
		}
		case 2: {	// 4h
			sint16[4] rn = read_register_bank(VB4H, inst.rn);
			sint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			sint16[4] mask = rn > rm;
			sint16[4] rd = (rn & ~mask) | (rm & mask);
			
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 3: {	// 8h
			sint16[8] rn = read_register_bank(VB8H, inst.rn);
			sint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			sint16[8] mask = rn > rm;
			sint16[8] rd = (rn & ~mask) | (rm & mask);
			
			write_register_bank(VB8H, inst.rd, rd);	
			break;
		}
		case 4: {	// 2s
			sint32[2] rn = read_register_bank(VB2S, inst.rn);
			sint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			sint32[2] mask = rn > rm;
			sint32[2] rd = (rn & ~mask) | (rm & mask);
			
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 5: {	// 4s
			sint32[4] rn = read_register_bank(VB4S, inst.rn);
			sint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			sint32[4] mask = rn > rm;
			sint32[4] rd = (rn & ~mask) | (rm & mask);
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
	}
}

execute(ushl)
{
	if (inst.SCALAR) {
		uint64 rn = read_vector_reg64(inst.rn);
		sint8 rm = (sint8)read_vector_reg64(inst.rm);
				
		if (rm > 63) {
			write_vector_reg64(inst.rd, 0);
		} else if (rm > 0) {
			write_vector_reg64(inst.rd, rn << rm);
		} else if (rm < -63) {
			write_vector_reg64(inst.rd, 0);
		} else {
			write_vector_reg64(inst.rd, rn >> -rm);
		}
	} else {
		switch (inst.arrangement) {
			case 0: {	// 8b
				uint8[8] rn = read_register_bank(VB8B, inst.rn);
				sint8[8] rm = read_register_bank(VB8B, inst.rm);

				uint8[16] rd = (uint8)0;
				for (uint8 e = 0; e < 8; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB16B, inst.rd, rd);				
				break;
			}
			case 1: {	// 16b		
				uint8[16] rn = read_register_bank(VB16B, inst.rn);
				sint8[16] rm = read_register_bank(VB16B, inst.rm);
				
				uint8[16] rd = (uint8)0;
				for (uint8 e = 0; e < 16; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB16B, inst.rd, rd);				
				break;
			}
			case 2: {	// 4h
				uint16[4] rn = read_register_bank(VB4H, inst.rn);
				sint16[4] rm = read_register_bank(VB4H, inst.rm);
				
				uint16[8] rd = (uint16)0;
				for (uint8 e = 0; e < 4; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB8H, inst.rd, rd);				
				break;
			}
			case 3: {	// 8h		
				uint16[8] rn = read_register_bank(VB8H, inst.rn);
				sint16[8] rm = read_register_bank(VB8H, inst.rm);
				
				uint16[8] rd = (uint16)0;
				for (uint8 e = 0; e < 8; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB8H, inst.rd, rd);				
				break;
			}
			case 4: {	// 2s
				uint32[2] rn = read_register_bank(VB2S, inst.rn);
				sint32[2] rm = read_register_bank(VB2S, inst.rm);
				
				uint32[4] rd = (uint32)0;
				for (uint8 e = 0; e < 2; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB4S, inst.rd, rd);				
				break;
			}
			case 5: {	// 4s
				uint32[4] rn = read_register_bank(VB4S, inst.rn);
				sint32[4] rm = read_register_bank(VB4S, inst.rm);
				
				uint32[4] rd = (uint32)0;
				for (uint8 e = 0; e < 4; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB4S, inst.rd, rd);				
				break;
			}
			case 6: {	// 2d
				uint64[2] rn = read_register_bank(VB2D, inst.rn);
				sint64[2] rm = read_register_bank(VB2D, inst.rm);
				
				uint64[2] rd = (uint64)0;
				for (uint8 e = 0; e < 2; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB2D, inst.rd, rd);				
				break;
			}
			default: {
				trap();
				break;
			}
		}
	}
}

execute(sshl)
{
	if (inst.SCALAR) {
		sint64 rn = read_vector_reg64(inst.rn);
		sint64 rm = read_vector_reg64(inst.rm);
				
		if (rm < 0) {
			write_vector_reg64(inst.rd, rn >> -rm);
		} else {
			write_vector_reg64(inst.rd, rn << rm);
		}
	} else {
		switch (inst.arrangement) {
			case 0: {	// 8b
				sint8[8] rn = read_register_bank(VB8B, inst.rn);
				sint8[8] rm = read_register_bank(VB8B, inst.rm);

				uint8[16] rd = (uint8)0;
				for (uint8 e = 0; e < 8; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB16B, inst.rd, rd);				
				break;
			}
			case 1: {	// 16b		
				sint8[16] rn = read_register_bank(VB16B, inst.rn);
				sint8[16] rm = read_register_bank(VB16B, inst.rm);
				
				uint8[16] rd = (uint8)0;
				for (uint8 e = 0; e < 16; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB16B, inst.rd, rd);				
				break;
			}
			case 2: {	// 4h
				sint16[4] rn = read_register_bank(VB4H, inst.rn);
				sint16[4] rm = read_register_bank(VB4H, inst.rm);
				
				uint16[8] rd = (uint16)0;
				for (uint8 e = 0; e < 4; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB8H, inst.rd, rd);				
				break;
			}
			case 3: {	// 8h		
				sint16[8] rn = read_register_bank(VB8H, inst.rn);
				sint16[8] rm = read_register_bank(VB8H, inst.rm);
				
				uint16[8] rd = (uint16)0;
				for (uint8 e = 0; e < 8; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB8H, inst.rd, rd);				
				break;
			}
			case 4: {	// 2s
				sint32[2] rn = read_register_bank(VB2S, inst.rn);
				sint32[2] rm = read_register_bank(VB2S, inst.rm);
				
				uint32[4] rd = (uint32)0;
				for (uint8 e = 0; e < 2; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB4S, inst.rd, rd);				
				break;
			}
			case 5: {	// 4s
				sint32[4] rn = read_register_bank(VB4S, inst.rn);
				sint32[4] rm = read_register_bank(VB4S, inst.rm);
				
				uint32[4] rd = (uint32)0;
				for (uint8 e = 0; e < 4; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB4S, inst.rd, rd);				
				break;
			}
			case 6: {	// 2d
				sint64[2] rn = read_register_bank(VB2D, inst.rn);
				sint64[2] rm = read_register_bank(VB2D, inst.rm);
				
				uint64[2] rd = (uint64)0;
				for (uint8 e = 0; e < 2; e++) {
					if (rm[e] < 0) {
						rd[e] = rn[e] >> -rm[e];
					} else {
						rd[e] = rn[e] << rm[e];
					}
				}
				
				write_register_bank(VB2D, inst.rd, rd);				
				break;
			}
			default: {
				trap();
				break;
			}
		}
	}
}

execute(shll)
{
	trap();
}

execute(sshll)
{
	switch (inst.arrangement) {
		case 0: {	// 8b
			sint8[8] rn = read_register_bank(VB8B, inst.rn);
		
			sint16[8] rd = (sint16)0;
			for (uint8 i = 0; i < 8; i++) {
				rd[i] = ((sint16)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 1: {	// 16b		
			sint8[16] rn = read_register_bank(VB16B, inst.rn);
		
			sint16[8] rd = (sint16)0;
			for (uint8 i = 8; i < 16; i++) {
				rd[i - 8] = ((sint16)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 2: {	// 4h
			sint16[4] rn = read_register_bank(VB4H, inst.rn);
		
			sint32[4] rd = (sint32)0;
			for (uint8 i = 0; i < 4; i++) {
				rd[i] = ((sint32)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 3: {	// 8h		
			sint16[8] rn = read_register_bank(VB8H, inst.rn);
		
			sint32[4] rd = (sint32)0;
			for (uint8 i = 4; i < 8; i++) {
				rd[i - 4] = ((sint32)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 4: {	// 2s
			sint32[2] rn = read_register_bank(VB2S, inst.rn);
		
			sint64[2] rd = (sint64)0;
			for (uint8 i = 0; i < 2; i++) {
				rd[i] = ((sint64)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		case 5: {	// 4s
			sint32[4] rn = read_register_bank(VB4S, inst.rn);
		
			sint64[2] rd = (sint64)0;
			for (uint8 i = 2; i < 4; i++) {
				rd[i - 2] = ((sint64)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
	}
}

execute(ushll)
{
	switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
		
			uint16[8] rd = (uint16)0;
			for (uint8 i = 0; i < 8; i++) {
				rd[i] = ((uint16)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 1: {	// 16b		
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
		
			uint16[8] rd = (uint16)0;
			for (uint8 i = 8; i < 16; i++) {
				rd[i - 8] = ((uint16)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 2: {	// 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
		
			uint32[4] rd = (uint32)0;
			for (uint8 i = 0; i < 4; i++) {
				rd[i] = ((uint32)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 3: {	// 8h		
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
		
			uint32[4] rd = (uint32)0;
			for (uint8 i = 4; i < 8; i++) {
				rd[i - 4] = ((uint32)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 4: {	// 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
		
			uint64[2] rd = (uint64)0;
			for (uint8 i = 0; i < 2; i++) {
				rd[i] = ((uint64)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		case 5: {	// 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
		
			uint64[2] rd = (uint64)0;
			for (uint8 i = 2; i < 4; i++) {
				rd[i - 2] = ((uint64)rn[i]) << inst.shift_amount;
			}
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
	}
}

execute(uaddlp)
{
	switch (inst.arrangement) {
		case 0: {	// 8b -> 4h
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint16[4] rd = (uint16)0;
			
			for (uint8 e = 0; e < 4; e++) {
				rd[e] = (uint16)rn[2*e] + (uint16)rn[(2*e)+1];
			}
			
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 1: {	// 16b -> 8h
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint16[8] rd = (uint16)0;
			
			for (uint8 e = 0; e < 8; e++) {
				rd[e] = (uint16)rn[2*e] + (uint16)rn[(2*e)+1];
			}
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 2: {	// 4h -> 2s
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint32[2] rd = (uint32)0;
			
			for (uint8 e = 0; e < 2; e++) {
				rd[e] = (uint32)rn[2*e] + (uint32)rn[(2*e)+1];
			}
			
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 3: {	// 8h -> 4s
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint32[4] rd = (uint32)0;
			
			for (uint8 e = 0; e < 4; e++) {
				rd[e] = (uint32)rn[2*e] + (uint32)rn[(2*e)+1];
			}
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 4: {	// 2s -> 1d
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint64[2] rd = (uint64)0;
			
			rd[0] = (uint64)rn[0] + (uint64)rn[1];
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		case 5: {	// 4s -> 2d
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint64[2] rd = (uint64)0;
			
			rd[0] = (uint64)rn[0] + (uint64)rn[1];
			rd[1] = (uint64)rn[2] + (uint64)rn[3];
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
	}
}

execute(uadalp)
{
	switch (inst.arrangement) {
		case 0: {	// 8b -> 4h
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint16[4] rd = read_register_bank(VB4H, inst.rd);
			
			for (uint8 e = 0; e < 4; e++) {
				rd[e] += (uint16)rn[2*e] + (uint16)rn[(2*e)+1];
			}
			
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 1: {	// 16b -> 8h
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint16[8] rd = read_register_bank(VB8H, inst.rd);
			
			for (uint8 e = 0; e < 8; e++) {
				rd[e] += (uint16)rn[2*e] + (uint16)rn[(2*e)+1];
			}
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 2: {	// 4h -> 2s
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint32[2] rd = read_register_bank(VB2S, inst.rd);
			
			for (uint8 e = 0; e < 2; e++) {
				rd[e] += (uint32)rn[2*e] + (uint32)rn[(2*e)+1];
			}
			
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 3: {	// 8h -> 4s
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint32[4] rd = read_register_bank(VB4S, inst.rd);
			
			for (uint8 e = 0; e < 4; e++) {
				rd[e] += (uint32)rn[2*e] + (uint32)rn[(2*e)+1];
			}
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 4: {	// 2s -> 1d
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint64[2] rd = read_register_bank(VB2D, inst.rd);
			
			rd[0] += (uint64)rn[0] + (uint64)rn[1];
			rd[1] = 0;
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		case 5: {	// 4s -> 2d
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint64[2] rd = read_register_bank(VB2D, inst.rd);
			
			rd[0] += (uint64)rn[0] + (uint64)rn[1];
			rd[1] += (uint64)rn[2] + (uint64)rn[3];
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
	}
}

execute(abs_simd)
{
	if (inst.SCALAR) {
		sint64 rn = (sint64)read_vector_reg64(inst.rn);
		write_vector_reg64(inst.rd, __builtin_abs64(rn));
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			sint8[8] rn = (sint8[8])read_register_bank(VB8B, inst.rn);
			
			uint8[16] rd = 0;
			for (uint8 i = 0; i < 8; i++) {
				rd[i] = __builtin_abs32(rn[i]);
			}
			
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 1: {	// 16b
			sint8[16] rn = (sint8[16])read_register_bank(VB16B, inst.rn);
			
			uint8[16] rd = 0;
			for (uint8 i = 0; i < 16; i++) {
				rd[i] = __builtin_abs32(rn[i]);
			}
			
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 2: {	// 4h
			sint16[4] rn = (sint16[4])read_register_bank(VB4H, inst.rn);
			
			uint16[8] rd = 0;
			for (uint8 i = 0; i < 4; i++) {
				rd[i] = __builtin_abs32(rn[i]);
			}
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 3: {	// 8h
			sint16[8] rn = (sint16[8])read_register_bank(VB8H, inst.rn);
			
			uint16[8] rd = 0;
			for (uint8 i = 0; i < 8; i++) {
				rd[i] = __builtin_abs32(rn[i]);
			}
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: {	// 2s
			sint32[2] rn = (sint32[2])read_register_bank(VB2S, inst.rn);
			
			uint32[4] rd = 0;
			for (uint8 i = 0; i < 2; i++) {
				rd[i] = __builtin_abs32(rn[i]);
			}
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 5: {	// 4s
			sint32[4] rn = (sint32[4])read_register_bank(VB4S, inst.rn);
			
			uint32[4] rd = 0;
			for (uint8 i = 0; i < 4; i++) {
				rd[i] = __builtin_abs32(rn[i]);
			}
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: {	// 2d
			sint64[2] rn = (sint64[2])read_register_bank(VB2D, inst.rn);
			
			uint64[2] rd = 0;
			for (uint8 i = 0; i < 2; i++) {
				rd[i] = __builtin_abs64(rn[i]);
			}
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
	}
	}
}

helper void store_vector(uint8 size, uint8 rt, uint64 addr)
{
	switch (size) {
	case 0: {
		// 8-bit
		uint8 value = read_vector_reg8(rt);
		mem_write_8(Data, addr, value);
		break;
	}
	case 1: {
		// 16-bit
		uint16 value = read_vector_reg16(rt);
		mem_write_16(Data, addr, value);
		break;
	}
	case 2: {
		// 32-bit
		uint32 value = read_vector_reg32(rt);
		mem_write_32(Data, addr, value);
		break;
	}
	case 3: {
		// 64-bit
		uint64 value = read_vector_reg64(rt);
		mem_write_64(Data, addr, value);
		break;
	}
	case 4: {
		// 128-bit
		uint64 vl;
		uint64 vh;
		read_vector_reg128(rt, vl, vh);
		mem_write_64(Data, addr, vl);
		mem_write_64(Data, addr+8, vh);
		break;
	}
	}
	return;
}

helper void load_vector(uint8 size, uint8 rt, uint64 addr)
{
	switch (size) {
	case 0: {
		// 8-bit
		uint8 value;
		mem_read_8(Data, addr, value);
		write_vector_reg8(rt, value);
		break;
	}
	case 1: {
		// 16-bit
		uint16 value;
		mem_read_16(Data, addr, value);
		write_vector_reg16(rt, value);
		break;
	}
	case 2: {
		// 32-bit
		uint32 value;
		mem_read_32(Data, addr, value);
		write_vector_reg32(rt, value);
		break;
	}
	case 3: {
		// 64-bit
		uint64 value;
		mem_read_64(Data, addr, value);
		write_vector_reg64(rt, value);
		break;
	}
	case 4: {
		// 128-bit
		uint64 vl;
		uint64 vh;
		mem_read_64(Data, addr, vl);
		mem_read_64(Data, addr+8, vh);
		write_vector_reg128(rt, vl, vh);
		break;
	}
	}
	return;
}

execute(tbl)
{
	if (inst.Q == 0) {
		for (uint8 i = 0; i < 8; i++) {
			uint8 rm = read_register_bank(TBL, (inst.rm * 16) + i);
		
			if (rm < (16 * (inst.len + 1))) {
				write_register_bank(TBL, (inst.rd * 16) + i, read_register_bank(TBL, (inst.rn * 16) + rm));
			} else {
				write_register_bank(TBL, (inst.rd * 16) + i, 0);
			}
		}
		
		write_register_bank(VBH, inst.rd, 0);
	} else {
		for (uint8 i = 0; i < 16; i++) {
			uint8 rm = read_register_bank(TBL, (inst.rm * 16) + i);
		
			if (rm < (16 * (inst.len + 1))) {
				write_register_bank(TBL, (inst.rd * 16) + i, read_register_bank(TBL, (inst.rn * 16) + rm));
			} else {
				write_register_bank(TBL, (inst.rd * 16) + i, 0);
			}
		}
	}
}

execute(tbx)
{
	if (inst.Q == 0) {
		for (uint8 i = 0; i < 8; i++) {
			uint8 rm = read_register_bank(TBL, (inst.rm * 16) + i);
		
			if (rm < (16 * (inst.len + 1))) {
				write_register_bank(TBL, (inst.rd * 16) + i, read_register_bank(TBL, (inst.rn * 16) + rm));
			}
		}
		
		write_register_bank(VBH, inst.rd, 0);
	} else {
		for (uint8 i = 0; i < 16; i++) {
			uint8 rm = read_register_bank(TBL, (inst.rm * 16) + i);
		
			if (rm < (16 * (inst.len + 1))) {
				write_register_bank(TBL, (inst.rd * 16) + i, read_register_bank(TBL, (inst.rn * 16) + rm));
			}
		}
	}
}

helper void load_vector_lane(uint8 arrg, uint8 rt, uint8 lane, uint64 addr)
{
	switch (arrg) {
	case 0: {	// 8b
		uint8 mem_value;
		mem_read_8(Data, addr, mem_value);

		uint8[8] vector_value = read_register_bank(VB8B, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB8B, rt, vector_value);
		break;
	}
	case 1: {	// 16b
		uint8 mem_value;
		mem_read_8(Data, addr, mem_value);

		uint8[16] vector_value = read_register_bank(VB16B, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB16B, rt, vector_value);
		break;
	}
	case 2: {	// 4h
		uint16 mem_value;
		mem_read_16(Data, addr, mem_value);

		uint16[4] vector_value = read_register_bank(VB4H, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB4H, rt, vector_value);
		break;
	}
	case 3: {	// 8h
		uint16 mem_value;
		mem_read_16(Data, addr, mem_value);

		uint16[8] vector_value = read_register_bank(VB8H, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB8H, rt, vector_value);
		break;
	}
	case 4: {	// 2s
		uint32 mem_value;
		mem_read_32(Data, addr, mem_value);

		uint32[2] vector_value = read_register_bank(VB2S, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB2S, rt, vector_value);
		break;
	}
	case 5: {	// 4s
		uint32 mem_value;
		mem_read_32(Data, addr, mem_value);

		uint32[4] vector_value = read_register_bank(VB4S, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB4S, rt, vector_value);
		break;
	}
	case 6: {	// 2d
		uint64 mem_value;
		mem_read_64(Data, addr, mem_value);

		uint64[2] vector_value = read_register_bank(VB2D, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB2D, rt, vector_value);
		break;
	}
	default: {
		trap();
		break;
	}
	}
	return;
}

helper void store_vector_lane(uint8 arrg, uint8 rt, uint8 lane, uint64 addr)
{
	switch (arrg) {
	case 0: {	// 8b
		uint8[8] vector_value = read_register_bank(VB8B, rt);
		mem_write_8(Data, addr, vector_value[lane]);
		break;
	}
	case 1: {	// 16b
		uint8[16] vector_value = read_register_bank(VB16B, rt);
		mem_write_8(Data, addr, vector_value[lane]);
		break;
	}
	case 2: {	// 4h
		uint16[4] vector_value = read_register_bank(VB4H, rt);
		mem_write_16(Data, addr, vector_value[lane]);
		break;
	}
	case 3: {	// 8h
		uint16[8] vector_value = read_register_bank(VB8H, rt);
		mem_write_16(Data, addr, vector_value[lane]);
		break;
	}
	case 4: {	// 2s
		uint32[2] vector_value = read_register_bank(VB2S, rt);
		mem_write_32(Data, addr, vector_value[lane]);
		break;
	}
	case 5: {	// 4s
		uint32[4] vector_value = read_register_bank(VB4S, rt);
		mem_write_32(Data, addr, vector_value[lane]);
		break;
	}
	case 6: {	// 2d
		uint64[2] vector_value = read_register_bank(VB2D, rt);
		mem_write_64(Data, addr, vector_value[lane]);
		break;
	}
	default: {
		trap();
		break;
	}
	}
	return;
}

execute(vstr)
{
	uint64 addr = read_gpr_sp(1, inst.rn) + inst.immu64;
	store_vector(((inst.size == 0) ? ((inst.opc == 0) ? ((uint8)0) : ((uint8)4)) : ((uint8)inst.size)), inst.rt, addr);
}

execute(vldr)
{
	uint64 addr = read_gpr_sp(1, inst.rn) + inst.immu64;
	load_vector(((inst.size == 0) ? ((inst.opc == 1) ? ((uint8)0) : ((uint8)4)) : ((uint8)inst.size)), inst.rt, addr);
}

execute(vstur)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	addr += inst.imms64;
	
	store_vector(((inst.size == 0) ? ((inst.opc == 0) ? ((uint8)0) : ((uint8)4)) : ((uint8)inst.size)), inst.rt, addr);
}

execute(vldur)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	addr += inst.imms64;
	
	load_vector(((inst.size == 0) ? ((inst.opc == 1) ? ((uint8)0) : ((uint8)4)) : ((uint8)inst.size)), inst.rt, addr);
}

execute(ldr_lit_simd)
{
	uint64 address = read_pc() + inst.label;
	
	switch (inst.opc) {
	case 0: {
		load_vector(2, inst.rt, address);
		break;
	}
	case 1: {
		load_vector(3, inst.rt, address);
		break;
	}
	case 2: {
		load_vector(4, inst.rt, address);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(ldr_reg_simd)
{
	uint8 shift = (inst.S == 0) ? (uint8)0 : ((inst.X == 1) ? ((uint8)4) : ((uint8)inst.size));
	
	uint64 rm;
	if (inst.option0 == 0 && inst.option21 == 1) {			// UXTW
		rm = extend_reg(0, inst.rm, 2, shift);
	} else if (inst.option0 == 0 && inst.option21 == 3) {	// SXTW
		rm = extend_reg(0, inst.rm, 6, shift);
	} else if (inst.option0 == 1 && inst.option21 == 1) {	// LSL (UXTX)
		rm = extend_reg(1, inst.rm, 3, shift);
	} else if (inst.option0 == 1 && inst.option21 == 3) {	// SXTX
		rm = extend_reg(1, inst.rm, 7, shift);
	} else {
		rm = 0;
		trap();
	}
	
	uint64 address = read_gpr_sp(1, inst.rn) + rm;
	
	if (inst.size == 0) {
		if (inst.X == 1) {
			// 128
			load_vector(4, inst.rt, address);
		} else {
			// 8
			load_vector(0, inst.rt, address);
		}
	} else if (inst.size == 1) {
		// 16
		load_vector(1, inst.rt, address);
	} else if (inst.size == 2) {
		// 32
		load_vector(2, inst.rt, address);
	} else if (inst.size == 3) {
		// 64
		load_vector(3, inst.rt, address);
	}
}

execute(str_reg_simd)
{
	uint8 shift = (inst.S == 0) ? (uint8)0 : ((inst.X == 1) ? ((uint8)4) : ((uint8)inst.size));
	
	uint64 rm;
	if (inst.option0 == 0 && inst.option21 == 1) {			// UXTW
		rm = extend_reg(0, inst.rm, 2, shift);
	} else if (inst.option0 == 0 && inst.option21 == 3) {	// SXTW
		rm = extend_reg(0, inst.rm, 6, shift);
	} else if (inst.option0 == 1 && inst.option21 == 1) {	// LSL (UXTX)
		rm = extend_reg(1, inst.rm, 3, shift);
	} else if (inst.option0 == 1 && inst.option21 == 3) {	// SXTX
		rm = extend_reg(1, inst.rm, 7, shift);
	} else {
		rm = 0;
		trap();
	}
	
	uint64 address = read_gpr_sp(1, inst.rn) + rm;
	
	if (inst.size == 0) {
		if (inst.X == 1) {
			// 128
			store_vector(4, inst.rt, address);
		} else {
			// 8
			store_vector(0, inst.rt, address);
		}
	} else if (inst.size == 1) {
		// 16
		store_vector(1, inst.rt, address);
	} else if (inst.size == 2) {
		// 32
		store_vector(2, inst.rt, address);
	} else if (inst.size == 3) {
		// 64
		store_vector(3, inst.rt, address);
	}
}

execute(fmov)
{
	if (inst.type == 0) {
		write_float_reg32(inst.rd, read_float_reg32(inst.rn));
	} else {
		write_float_reg64(inst.rd, read_float_reg64(inst.rn));
	}
}

execute(fneg)
{
	if (inst.type == 0) {
		write_float_reg32(inst.rd, -read_float_reg32(inst.rn));
	} else {
		write_float_reg64(inst.rd, -read_float_reg64(inst.rn));
	}
}

execute(fmov_gen)
{
	if (inst.sf == 0 && inst.type == 0 && inst.rmode == 0 && inst.opcode == 7) {
		// 32-bit to single-precision
		write_register_bank(VS, inst.rd, read_gpr(0, inst.rn));
		write_register_bank(FSH, inst.rd, 0);
		write_register_bank(VBH, inst.rd, 0);
	} else if (inst.sf == 0 && inst.type == 0 && inst.rmode == 0 && inst.opcode == 6) {
		// Single-precision to 32-bit
		write_gpr(0, inst.rd, read_register_bank(VS, inst.rn));
	} else if (inst.sf == 1 && inst.type == 1 && inst.rmode == 0 && inst.opcode == 7) {
		// 64-bit to double-precision
		write_register_bank(VD, inst.rd, read_gpr(1, inst.rn));
		write_register_bank(VBH, inst.rd, 0);
	} else if (inst.sf == 1 && inst.type == 2 && inst.rmode == 1 && inst.opcode == 7) {
		// 64-bit to top-half of 128-bit
		write_register_bank(VBH, inst.rd, read_gpr(1, inst.rn));
	} else if (inst.sf == 1 && inst.type == 1 && inst.rmode == 0 && inst.opcode == 6) {
		// Double-precision to 64-bit
		write_gpr(1, inst.rd, read_register_bank(VD, inst.rn));
	} else if (inst.sf == 1 && inst.type == 2 && inst.rmode == 1 && inst.opcode == 6) {
		// Top-half of 128-bit to 64-bit
		write_gpr(1, inst.rd, read_register_bank(VBH, inst.rn));
	} else {
		trap();
	}
}

execute(fadd)
{
	if (inst.type == 0) {
		// f32
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);
		
		float result = n + m;
		write_float_reg32(inst.rd, result);
	} else {
		/*uint64 n = read_register_bank(VD, inst.rn);
		uint64 m = read_register_bank(VD, inst.rm);
		uint64 d = __softfp_add64(n, m);
		write_register_bank(VD, inst.rd, d);*/
	
		// f64
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);
		
		double result = n + m;
		write_float_reg64(inst.rd, result);
	}	
}

execute(fsub)
{
	if (inst.type == 0) {
		// f32
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);
		
		float result = n - m;
		write_float_reg32(inst.rd, result);
	} else {
		// f64
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);
		
		double result = n - m;
		write_float_reg64(inst.rd, result);
	}	
}

execute(fmul)
{
	if (inst.type == 0) {
		// f32
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);
		
		float result = n * m;
		write_float_reg32(inst.rd, result);
	} else {
		// f64
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);
		
		double result = n * m;
		write_float_reg64(inst.rd, result);
	}	
}

execute(fnmul)
{
	if (inst.type == 0) {
		// f32
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);
		
		float result = -(n * m);
		write_float_reg32(inst.rd, result);
	} else {
		// f64
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);
		
		double result = -(n * m);
		write_float_reg64(inst.rd, result);
	}	
}

execute(fdiv)
{
	if (inst.type == 0) {
		// f32
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);
		
		float result = n / m;
		write_float_reg32(inst.rd, result);
	} else {
		// f64
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);
		
		double result = n / m;
		write_float_reg64(inst.rd, result);
	}	
}

execute(fm)
{
	if (inst.type == 0) {
		// f32
		float a = read_float_reg32(inst.ra);
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);

		if (inst.o0 == 0) {
			float result = __builtin_fma32(n, m, a);	// (n * m) + a;
			write_float_reg32(inst.rd, result);
		} else {
			float result = __builtin_fma32(-n, m, a);	// (-n * m) + a;
			write_float_reg32(inst.rd, result);
		}
	} else {
		// f64
		double a = read_float_reg64(inst.ra);
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);

		if (inst.o0 == 0) {
			double result = __builtin_fma64(n, m, a);	// (n * m) + a;
			write_float_reg64(inst.rd, result);
		} else {
			double result = __builtin_fma64(-n, m, a);	// (-n * m) + a;
			write_float_reg64(inst.rd, result);
		}
	}
}

execute(fnm)
{
	if (inst.type == 0) {
		// f32
		double a = -(double)read_float_reg32(inst.ra);
		double n = -(double)read_float_reg32(inst.rn);
		double m = (double)read_float_reg32(inst.rm);

		if (inst.o0 == 0) {
			float result = __builtin_fma32(n, m, a); // (n * m) + a;
			write_float_reg32(inst.rd, result);
		} else {
			float result = __builtin_fma32(-n, m, a); // (-n * m) + a;
			write_float_reg32(inst.rd, result);
		}
	} else {
		// f64
		double a = -(double)read_float_reg64(inst.ra);
		double n = -(double)read_float_reg64(inst.rn);
		double m = (double)read_float_reg64(inst.rm);

		if (inst.o0 == 0) {
			double result = __builtin_fma64(n, m, a); // (n * m) + a;
			write_float_reg64(inst.rd, result);
		} else {
			double result = __builtin_fma64(-n, m, a); // (-n * m) + a;
			write_float_reg64(inst.rd, result);
		}
	}
}

execute(scvtf)
{
	if (inst.sf == 0) {
		if (inst.type == 0) {
			// 32-bit to sp
			write_float_reg32(inst.rd, (float)(sint32)read_gpr(0, inst.rn));
		} else if (inst.type == 1) {
			// 32-bit to dp
			write_float_reg64(inst.rd, (double)(sint32)read_gpr(0, inst.rn));
		}
	} else if (inst.sf == 1) {
		if (inst.type == 0) {
			// 64-bit to sp
			write_float_reg32(inst.rd, (float)(sint64)read_gpr(1, inst.rn));
		} else if (inst.type == 1) {
			// 64-bit to dp
			write_float_reg64(inst.rd, (double)(sint64)read_gpr(1, inst.rn));
		}
	}
	
}

execute(scvtf_simd)
{
	if (inst.SCALAR) {
		if (inst.size == 0) {
			// s32 -> f32
			write_float_reg32(inst.rd, (float)(sint32)read_vector_reg32(inst.rn));
		} else {
			// s64 -> f64
			write_float_reg64(inst.rd, (double)(sint64)read_vector_reg64(inst.rn));
		}
	} else {
		if (inst.size == 0 && inst.Q == 0) {		// 2S
			sint32[2] rn = read_register_bank(VB2S, inst.rn);
			
			float[2] rd = (float)0;
			rd[0] = (float)rn[0];
			rd[1] = (float)rn[1];
			
			write_register_bank(VF2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
		} else if (inst.size == 0 && inst.Q == 1) {	// 4S
			sint32[4] rn = read_register_bank(VB4S, inst.rn);
			
			float[4] rd = (float)0;
			rd[0] = (float)rn[0];
			rd[1] = (float)rn[1];
			rd[2] = (float)rn[2];
			rd[3] = (float)rn[3];
			
			write_register_bank(VF4S, inst.rd, rd);
		} else if (inst.size == 1 && inst.Q == 1) {	// 2D
			sint64[2] rn = read_register_bank(VB2D, inst.rn);
			
			double[2] rd = (double)0;
			rd[0] = (double)rn[0];
			rd[1] = (double)rn[1];
			
			write_register_bank(VF2D, inst.rd, rd);
		} else {
			trap();
		}
	}
}

execute(ucvtf_simd)
{
	if (inst.SCALAR) {
		if (inst.size == 0) {
			// u32 -> f32
			write_float_reg32(inst.rd, (float)(uint32)read_vector_reg32(inst.rn));
		} else {
			// u64 -> f64
			write_float_reg64(inst.rd, (double)(uint64)read_vector_reg64(inst.rn));
		}
	} else {
		if (inst.size == 0 && inst.Q == 0) {		// 2S
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			
			float[2] rd = (float)0;
			rd[0] = (float)rn[0];
			rd[1] = (float)rn[1];
						
			write_register_bank(VF2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
		} else if (inst.size == 0 && inst.Q == 1) {	// 4S
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			
			float[4] rd = (float)0;
			rd[0] = (float)rn[0];
			rd[1] = (float)rn[1];
			rd[2] = (float)rn[2];
			rd[3] = (float)rn[3];
			
			write_register_bank(VF4S, inst.rd, rd);
		} else if (inst.size == 1 && inst.Q == 1) {	// 2D
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			
			double[2] rd = (double)0;
			rd[0] = (double)rn[0];
			rd[1] = (double)rn[1];
			
			write_register_bank(VF2D, inst.rd, rd);
		} else {
			trap();
		}
	}
}

execute(ucvtf)
{
	if (inst.sf == 0) {
		if (inst.type == 0) {
			// 32-bit to sp
			write_float_reg32(inst.rd, (float)(uint32)read_gpr(0, inst.rn));
		} else if (inst.type == 1) {
			// 32-bit to dp
			write_float_reg64(inst.rd, (double)(uint32)read_gpr(0, inst.rn));
		}
	} else if (inst.sf == 1) {
		if (inst.type == 0) {
			// 64-bit to sp
			write_float_reg32(inst.rd, (float)(uint64)read_gpr(1, inst.rn));
		} else if (inst.type == 1) {
			// 64-bit to dp
			write_float_reg64(inst.rd, (double)(uint64)read_gpr(1, inst.rn));
		}
	}
}

execute(fcvtz)
{
	if (inst.opcode == 0) {
		// Signed
		if (inst.sf == 0) {
			if (inst.type == 0) {
				// f32 to s32				
				write_gpr32(inst.rd, (uint32)(sint32)read_float_reg32(inst.rn));
			} else {
				// f64 to s32
				write_gpr32(inst.rd, (uint32)(sint32)read_float_reg64(inst.rn));
			}
		} else {
			if (inst.type == 0) {
				// f32 to s64
				write_gpr64(inst.rd, (uint64)(sint64)read_float_reg32(inst.rn));
			} else {
				// f64 to s64
				write_gpr64(inst.rd, (uint64)(sint64)read_float_reg64(inst.rn));
			}
		}
	} else {
		// Unsigned
		if (inst.sf == 0) {
			if (inst.type == 0) {
				// f32 to u32
				write_gpr32(inst.rd, (uint32)read_float_reg32(inst.rn));
			} else {
				// f64 to u32
				write_gpr32(inst.rd, (uint32)read_float_reg64(inst.rn));
			}
		} else {
			if (inst.type == 0) {
				// f32 to u64
				write_gpr64(inst.rd, (uint64)read_float_reg32(inst.rn));
			} else {
				// f64 to u64
				write_gpr64(inst.rd, (uint64)read_float_reg64(inst.rn));
			}
		}
	}
}

execute(fcvti)
{
	if (inst.opcode == 0 || inst.opcode == 4) {
		// Signed
		if (inst.sf == 0) {
			if (inst.type == 0) {
				// f32 to s32				
				write_gpr32(inst.rd, __builtin_fcvt_f32_s32(read_float_reg32(inst.rn), inst.rmode));
			} else {
				// f64 to s32
				write_gpr32(inst.rd, __builtin_fcvt_f64_s32(read_float_reg64(inst.rn), inst.rmode));
			}
		} else {
			if (inst.type == 0) {
				// f32 to s64
				write_gpr64(inst.rd, __builtin_fcvt_f32_s64(read_float_reg32(inst.rn), inst.rmode));
			} else {
				// f64 to s64
				write_gpr64(inst.rd, __builtin_fcvt_f64_s64(read_float_reg64(inst.rn), inst.rmode));
			}
		}
	} else if (inst.opcode == 1 || inst.opcode == 5) {
		// Unsigned
		if (inst.sf == 0) {
			if (inst.type == 0) {
				// f32 to u32
				write_gpr32(inst.rd, __builtin_fcvt_f32_u32(read_float_reg32(inst.rn), inst.rmode));
			} else {
				// f64 to u32
				write_gpr32(inst.rd, __builtin_fcvt_f64_u32(read_float_reg64(inst.rn), inst.rmode));
			}
		} else {
			if (inst.type == 0) {
				// f32 to u64
				write_gpr64(inst.rd, __builtin_fcvt_f32_u64(read_float_reg32(inst.rn), inst.rmode));
			} else {
				// f64 to u64
				write_gpr64(inst.rd, __builtin_fcvt_f64_u64(read_float_reg64(inst.rn), inst.rmode));
			}
		}
	} else {
		trap();
	}
}

execute(fcvt)
{
	if (inst.type == 0) {
		// f32
		if (inst.opcode == 5) {
			// f32 -> f64
			write_float_reg64(inst.rd, (double)read_float_reg32(inst.rn));
		} else {
			trap();
		}
	} else if (inst.type == 1) {
		// f64
		if (inst.opcode == 4) {
			// f64 -> f32
			write_float_reg32(inst.rd, (float)read_float_reg64(inst.rn));
		} else {
			trap();
		}
	} else {
		trap();
	}
}

execute (fcvtz_fxp)
{
	uint64 mulp = (uint64)1<<inst.immu64;
	
	if (inst.opcode == 0) {
		// Signed
		if (inst.sf == 0) {
			if (inst.type == 0) {
				// f32 to s32				
				write_gpr32(inst.rd, __builtin_fcvt_f32_s32(read_float_reg32(inst.rn) * mulp, inst.rmode));
			} else {
				// f64 to s32
				write_gpr32(inst.rd, __builtin_fcvt_f64_s32(read_float_reg64(inst.rn) * mulp, inst.rmode));
			}
		} else {
			if (inst.type == 0) {
				// f32 to s64
				write_gpr64(inst.rd, __builtin_fcvt_f32_s64(read_float_reg32(inst.rn) * mulp, inst.rmode));
			} else {
				// f64 to s64
				write_gpr64(inst.rd, __builtin_fcvt_f64_s64(read_float_reg64(inst.rn) * mulp, inst.rmode));
			}
		}
	} else {
		// Unsigned
		if (inst.sf == 0) {
			if (inst.type == 0) {
				// f32 to u32
				write_gpr32(inst.rd, __builtin_fcvt_f32_u32(read_float_reg32(inst.rn) * mulp, inst.rmode));
			} else {
				// f64 to u32
				write_gpr32(inst.rd, __builtin_fcvt_f64_u32(read_float_reg64(inst.rn) * mulp, inst.rmode));
			}
		} else {
			if (inst.type == 0) {
				// f32 to u64
				write_gpr64(inst.rd, __builtin_fcvt_f32_u64(read_float_reg32(inst.rn) * mulp, inst.rmode));
			} else {
				// f64 to u64
				write_gpr64(inst.rd, __builtin_fcvt_f64_u64(read_float_reg64(inst.rn) * mulp, inst.rmode));
			}
		}
	}
}

execute(ucvtf_fxp)
{
	if (inst.sf == 0) {
		uint32 intval = read_gpr32(inst.rn);
		uint32 realval = intval >> inst.immu64;
		
		if (inst.type == 0) {
			// u32 to f32
			write_float_reg32(inst.rd, (float)realval);
		} else if (inst.type == 1) {
			// u32 to f64
			write_float_reg64(inst.rd, (double)realval);
		} else {
			trap();
		}
	} else if (inst.sf == 1) {
		uint64 intval = read_gpr32(inst.rn);
		uint64 realval = intval >> inst.immu64;
	
		if (inst.type == 0) {
			// u64 to f32
			write_float_reg32(inst.rd, (float)realval);
		} else if (inst.type == 1) {
			// u64 to f64
			write_float_reg64(inst.rd, (double)realval);
		} else {
			trap();
		}
	}
}

execute(fcvtzs_simd)
{
	if (inst.U == 0) {
		if (inst.SCALAR == 1) {
			if (inst.size == 2) {
				// f32 -> s32
				write_vector_reg32(inst.rd, __builtin_fcvt_f32_s32(read_float_reg32(inst.rn), 3));
			} else {
				// f64 -> s64
				write_vector_reg64(inst.rd, __builtin_fcvt_f64_s64(read_float_reg64(inst.rn), 3));
			}
		} else {
			if (inst.Q == 0) {
				if (inst.size == 2) {
					// f32[2] -> s32[2]
					float[2] rn = read_register_bank(VF2S, inst.rn);
					
					sint32[2] rd = 0;
					rd[0] = __builtin_fcvt_f32_s32(rn[0], 3);
					rd[1] = __builtin_fcvt_f32_s32(rn[1], 3);
					
					write_register_bank(VB2S, inst.rd, rd);
				}
			} else if (inst.Q == 1) {
				if (inst.size == 2) {
					// f32[4] -> s32[4]
					float[4] rn = read_register_bank(VF4S, inst.rn);
					
					sint32[4] rd = 0;
					rd[0] = __builtin_fcvt_f32_s32(rn[0], 3);
					rd[1] = __builtin_fcvt_f32_s32(rn[1], 3);
					rd[2] = __builtin_fcvt_f32_s32(rn[2], 3);
					rd[3] = __builtin_fcvt_f32_s32(rn[3], 3);
					
					write_register_bank(VB4S, inst.rd, rd);
				} else if (inst.size == 3) {
					// f64[2] -> s64[2]
					double[2] rn = read_register_bank(VF2D, inst.rn);
					
					sint64[2] rd = 0;
					rd[0] = __builtin_fcvt_f64_s64(rn[0], 3);
					rd[1] = __builtin_fcvt_f64_s64(rn[1], 3);
					
					write_register_bank(VB2D, inst.rd, rd);
				}
			}
		}
	} else {
		if (inst.SCALAR == 1) {
			if (inst.size == 2) {
				// f32 -> u32
				write_vector_reg32(inst.rd, __builtin_fcvt_f32_u32(read_float_reg32(inst.rn), 3));
			} else {
				// f64 -> u64
				write_vector_reg64(inst.rd, __builtin_fcvt_f64_u64(read_float_reg64(inst.rn), 3));
			}
		} else {
			trap();
		}
	}
}

execute(fcvtas_simd)
{
	if (inst.SCALAR == 1) {
		if (inst.size == 0) {
			// f32 -> s32
			write_vector_reg32(inst.rd, __builtin_fcvt_f32_s32(read_float_reg32(inst.rn), 0));
		} else {
			// f64 -> s64
			write_vector_reg64(inst.rd, __builtin_fcvt_f64_s64(read_float_reg64(inst.rn), 0));
		}
	} else {
		trap();
	}
}

execute(frintx)
{
	uint8 rmode;
	switch (inst.opcode) {
	case 8: {
		rmode = 0;
		break;
	}
	case 9: {
		rmode = 1;
		break;
	}
	case 10: {
		rmode = 2;
		break;
	}
	case 11: {
		rmode = 3;
		break;
	}
	case 12: {
		rmode = 0;
		break;
	}
	case 14: {
		rmode = __builtin_get_fp_rounding();
		break;
	}
	case 15: {
		rmode = __builtin_get_fp_rounding();
		break;
	}
	default: {
		trap();
		break;
	}
	}

	if (inst.type == 0) {
		float v = read_float_reg32(inst.rn);
		write_float_reg32(inst.rd, __builtin_f32_round(v, rmode));
	} else {
		double v = read_float_reg64(inst.rn);
		write_float_reg64(inst.rd, __builtin_f64_round(v, rmode));
	}
}

execute(fsqrt)
{
	if (inst.type == 0) {
		write_float_reg32(inst.rd, float_sqrt(read_float_reg32(inst.rn)));
	} else {
		write_float_reg64(inst.rd, double_sqrt(read_float_reg64(inst.rn)));
	}
}

execute(fabs)
{
	if (inst.type == 0) {
		write_float_reg32(inst.rd, float_abs(read_float_reg32(inst.rn)));
	} else {
		write_float_reg64(inst.rd, double_abs(read_float_reg64(inst.rn)));
	}
}

execute(fcmpe)
{
	if (inst.type == 0) {
		// f32
		float rn = read_float_reg32(inst.rn);
		float rm = (inst.opcode2 == 0x18 || inst.opcode2 == 0x08) ? (float)0 : read_float_reg32(inst.rm);
		
		if (inst.opcode2 & 0x10) {
			__builtin_cmpf32e_flags(rn, rm);
		} else {
			__builtin_cmpf32_flags(rn, rm);
		}
	} else {
		// f64
		double rn = read_float_reg64(inst.rn);
		double rm = (inst.opcode2 == 0x18 || inst.opcode2 == 0x08) ? (double)0 : read_float_reg64(inst.rm);
		
		if (inst.opcode2 & 0x10) {
			__builtin_cmpf64e_flags(rn, rm);
		} else {
			__builtin_cmpf64_flags(rn, rm);
		}
	}
}

execute(fccmpe)
{
	uint8 check = check_cond(inst.cond);
	
	if (check == 0) {
		write_register(N, (inst.nzcv & 8) == 8);
		write_register(Z, (inst.nzcv & 4) == 4);
		write_register(C, (inst.nzcv & 2) == 2);
		write_register(V, (inst.nzcv & 1) == 1);
	} else {
		if (inst.type == 0) {
			// f32
			float rn = read_float_reg32(inst.rn);
			float rm = read_float_reg32(inst.rm);
			__builtin_cmpf32_flags(rn, rm);
		} else {
			// f64
			double rn = read_float_reg64(inst.rn);
			double rm = read_float_reg64(inst.rm);
			__builtin_cmpf64_flags(rn, rm);
		}
	}
}

execute(ushr)
{
	if (inst.SCALAR) {
		uint64 sa = (uint64)(128 - ((inst.immh << 3) | inst.immb));
		write_vector_reg64(inst.rd, read_vector_reg64(inst.rn) >> sa);
	} else {
		switch (inst.arrangement) {
		case 0: { // 8b
			uint64 sa = (uint64)(16 - ((inst.immh << 3) | inst.immb));
			
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			write_register_bank(VB8B, inst.rd, rn >> sa);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 1: { // 16b
			uint64 sa = (uint64)(16 - ((inst.immh << 3) | inst.immb));
			
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			write_register_bank(VB16B, inst.rd, rn >> sa);
			break;
		}
		case 2: { // 4h
			uint64 sa = (uint64)(32 - ((inst.immh << 3) | inst.immb));
		
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			write_register_bank(VB4H, inst.rd, rn >> sa);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 3: { // 8h
			uint64 sa = (uint64)(32 - ((inst.immh << 3) | inst.immb));
			
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			write_register_bank(VB8H, inst.rd, rn >> sa);
			break;
		}
		case 4: { // 2s
			uint64 sa = (uint64)(64 - ((inst.immh << 3) | inst.immb));
			
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			write_register_bank(VB2S, inst.rd, rn >> sa);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 5: { // 4s
			uint64 sa = (uint64)(64 - ((inst.immh << 3) | inst.immb));
			
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			write_register_bank(VB4S, inst.rd, rn >> sa);
			break;
		}
		case 6: { // 2d
			uint64 sa = (uint64)(128 - ((inst.immh << 3) | inst.immb));
			
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			write_register_bank(VB2D, inst.rd, rn >> sa);
			break;
		}
		}
	}
}

execute(sshr)
{
	if (inst.SCALAR) {
		uint64 sa = (uint64)(128 - ((inst.immh << 3) | inst.immb));
		write_vector_reg64(inst.rd, (uint64)((sint64)read_vector_reg64(inst.rn) >> sa));
	} else {
		switch (inst.arrangement) {
		case 0: { // 8b
			uint64 sa = (uint64)(16 - ((inst.immh << 3) | inst.immb));
			
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			write_register_bank(VB8B, inst.rd, (sint8[8])rn >> sa);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 1: { // 16b
			uint64 sa = (uint64)(16 - ((inst.immh << 3) | inst.immb));
			
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			write_register_bank(VB16B, inst.rd, (sint8[16])rn >> sa);
			break;
		}
		case 2: { // 4h
			uint64 sa = (uint64)(32 - ((inst.immh << 3) | inst.immb));
		
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			write_register_bank(VB4H, inst.rd, (sint16[4])rn >> sa);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 3: { // 8h
			uint64 sa = (uint64)(32 - ((inst.immh << 3) | inst.immb));
			
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			write_register_bank(VB8H, inst.rd, (sint16[8])rn >> sa);
			break;
		}
		case 4: { // 2s
			uint64 sa = (uint64)(64 - ((inst.immh << 3) | inst.immb));
			
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			write_register_bank(VB2S, inst.rd, (sint32[2])rn >> sa);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 5: { // 4s
			uint64 sa = (uint64)(64 - ((inst.immh << 3) | inst.immb));
			
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			write_register_bank(VB4S, inst.rd, (sint32[4])rn >> sa);
			break;
		}
		case 6: { // 2d
			uint64 sa = (uint64)(128 - ((inst.immh << 3) | inst.immb));
			
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			write_register_bank(VB2D, inst.rd, (sint64[2])rn >> sa);
			break;
		}
		}
	}
}

execute(shl_simd)
{
	if (inst.SCALAR) {
		write_vector_reg64(inst.rd, read_vector_reg64(inst.rn) << inst.shift_amount);
	} else {
		switch (inst.arrangement) {
		case 0: { // 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			write_register_bank(VB8B, inst.rd, rn << inst.shift_amount);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 1: { // 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			write_register_bank(VB16B, inst.rd, rn << inst.shift_amount);
			break;
		}
		case 2: { // 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			write_register_bank(VB4H, inst.rd, rn << inst.shift_amount);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 3: { // 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			write_register_bank(VB8H, inst.rd, rn << inst.shift_amount);
			break;
		}
		case 4: { // 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			write_register_bank(VB2S, inst.rd, rn << inst.shift_amount);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 5: { // 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			write_register_bank(VB4S, inst.rd, rn << inst.shift_amount);
			break;
		}
		case 6: { // 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			write_register_bank(VB2D, inst.rd, rn << inst.shift_amount);
			break;
		}
		}
	}
}

execute(movi)
{
	if (inst.Q == 0) {
		write_vector_reg64(inst.rd, inst.immu64);
	} else {
		write_vector_reg128(inst.rd, inst.immu64, inst.immu64);
	}
}

execute(mvni)
{
	if (inst.Q == 0) {
		write_vector_reg64(inst.rd, (~inst.immu64));
	} else {
		write_vector_reg128(inst.rd, (~inst.immu64), (~inst.immu64));
	}
}

execute(bici)
{
	if (inst.Q == 0) {
		uint64 rd = read_vector_reg64(inst.rd);
		write_vector_reg64(inst.rd, rd & (~inst.immu64));
	} else {
		uint64 rdh;
		uint64 rdl;
		
		read_vector_reg128(inst.rd, rdh, rdl);
		write_vector_reg128(inst.rd, rdh & (~inst.immu64), rdl & (~inst.immu64));
	}
}

execute(fmov_simd)
{
	if (inst.op == 0) {
		if (inst.Q == 0) {
			// 2s
			write_vector_reg64(inst.rd, inst.immu64);
		} else {
			// 4s
			write_vector_reg128(inst.rd, inst.immu64, inst.immu64);
		}
	} else if (inst.Q == 1 && inst.op == 1) {
		// 2d
		write_vector_reg128(inst.rd, inst.immu64, inst.immu64);
	}
}

execute(uzp1)
{
	switch (inst.arrangement) {
		case 0: { // 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			uint8[16] rd = (uint8)0;
			rd[0] = rn[0];
			rd[1] = rn[2];
			rd[2] = rn[4];
			rd[3] = rn[6];
			rd[4] = rm[0];
			rd[5] = rm[2];
			rd[6] = rm[4];
			rd[7] = rm[6];
			
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 1: { // 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			uint8[16] rd = (uint8)0;
			rd[0] = rn[0];
			rd[1] = rn[2];
			rd[2] = rn[4];
			rd[3] = rn[6];
			rd[4] = rn[8];
			rd[5] = rn[10];
			rd[6] = rn[12];
			rd[7] = rn[14];
			rd[8] = rm[0];
			rd[9] = rm[2];
			rd[10] = rm[4];
			rd[11] = rm[6];
			rd[12] = rm[8];
			rd[13] = rm[10];
			rd[14] = rm[12];
			rd[15] = rm[14];
			
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 2: { // 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			uint16[8] rd = (uint8)0;
			rd[0] = rn[0];
			rd[1] = rn[2];
			rd[2] = rm[0];
			rd[3] = rm[2];
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 3: { // 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			uint16[8] rd = (uint8)0;
			rd[0] = rn[0];
			rd[1] = rn[2];
			rd[2] = rn[4];
			rd[3] = rn[6];
			rd[4] = rm[0];
			rd[5] = rm[2];
			rd[6] = rm[4];
			rd[7] = rm[6];
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: { // 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			uint32[4] rd = (uint8)0;
			rd[0] = rn[0];
			rd[1] = rm[0];
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 5: { // 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			uint32[4] rd = (uint8)0;
			rd[0] = rn[0];
			rd[1] = rn[2];
			rd[2] = rm[0];
			rd[3] = rm[2];
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: { // 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			uint64[2] rm = read_register_bank(VB2D, inst.rm);
			
			uint64[2] rd = (uint8)0;
			rd[0] = rn[0];
			rd[1] = rm[0];
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		}
}

execute(uzp2)
{
	switch (inst.arrangement) {
		case 0: { // 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			uint8[16] rd = (uint8)0;
			rd[0] = rn[1];
			rd[1] = rn[3];
			rd[2] = rn[5];
			rd[3] = rn[7];
			rd[4] = rm[1];
			rd[5] = rm[3];
			rd[6] = rm[5];
			rd[7] = rm[7];
			
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 1: { // 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			uint8[16] rd = (uint8)0;
			rd[0] = rn[1];
			rd[1] = rn[3];
			rd[2] = rn[5];
			rd[3] = rn[7];
			rd[4] = rn[9];
			rd[5] = rn[11];
			rd[6] = rn[13];
			rd[7] = rn[15];
			rd[8] = rm[1];
			rd[9] = rm[3];
			rd[10] = rm[5];
			rd[11] = rm[7];
			rd[12] = rm[9];
			rd[13] = rm[11];
			rd[14] = rm[13];
			rd[15] = rm[15];
			
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 2: { // 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			uint16[8] rd = (uint8)0;
			rd[0] = rn[1];
			rd[1] = rn[3];
			rd[2] = rm[1];
			rd[3] = rm[3];
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 3: { // 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			uint16[8] rd = (uint8)0;
			rd[0] = rn[1];
			rd[1] = rn[3];
			rd[2] = rn[5];
			rd[3] = rn[7];
			rd[4] = rm[1];
			rd[5] = rm[3];
			rd[6] = rm[5];
			rd[7] = rm[7];
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: { // 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			uint32[4] rd = (uint8)0;
			rd[0] = rn[1];
			rd[1] = rm[1];
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 5: { // 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			uint32[4] rd = (uint8)0;
			rd[0] = rn[1];
			rd[1] = rn[3];
			rd[2] = rm[1];
			rd[3] = rm[3];
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: { // 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			uint64[2] rm = read_register_bank(VB2D, inst.rm);
			
			uint64[2] rd = (uint8)0;
			rd[0] = rn[1];
			rd[1] = rm[3];
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		}
}

execute(fcsel)
{
	uint8 check = check_cond(inst.cond);
	
	if (check == 0) {
		if (inst.type == 0) {
			write_float_reg32(inst.rd, read_float_reg32(inst.rm));
		} else {
			write_float_reg64(inst.rd, read_float_reg64(inst.rm));
		}
	} else {
		if (inst.type == 0) {
			write_float_reg32(inst.rd, read_float_reg32(inst.rn));
		} else {
			write_float_reg64(inst.rd, read_float_reg64(inst.rn));
		}
	}
}

execute(fmovi)
{
	if (inst.type == 0) {
		write_vector_reg32(inst.rd, vfp_expand_imm32(inst.imm8));
	} else {
		write_vector_reg64(inst.rd, vfp_expand_imm64(inst.imm8));
	}
}

execute(pmull)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		uint8[8] rm = read_register_bank(VB8B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = __builtin_polymul8(rn[i], rm[i]);
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		uint8[16] rm = read_register_bank(VB16B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = __builtin_polymul8(rn[i+8], rm[i+8]);
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 6: {	// 1d -> 1q
		uint64 rn = read_register_bank(VD, inst.rn);
		uint64 rm = read_register_bank(VD, inst.rm);
		
		uint128 rd = __builtin_polymul64(rn, rm);
		write_register_bank(VB1Q, inst.rd, rd);
		break;
	}
	case 7: {	// 2d -> 1q
		uint64[2] rn = read_register_bank(VB2D, inst.rn);
		uint64[2] rm = read_register_bank(VB2D, inst.rm);
		
		uint128 rd = __builtin_polymul64(rn[1], rm[1]);
		write_register_bank(VB1Q, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(smull)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		sint8[8] rn = (sint8[8])read_register_bank(VB8B, inst.rn);
		sint8[8] rm = (sint8[8])read_register_bank(VB8B, inst.rm);
		
		sint16[8] rd = (sint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (sint16)rn[i] * (sint16)rm[i];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		sint8[16] rn = (sint8[16])read_register_bank(VB16B, inst.rn);
		sint8[16] rm = (sint8[16])read_register_bank(VB16B, inst.rm);
		
		sint16[8] rd = (sint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (sint16)rn[i+8] * (sint16)rm[i+8];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 2: {	// 4h -> 4s
		sint16[4] rn = (sint16[4])read_register_bank(VB4H, inst.rn);
		sint16[4] rm = (sint16[4])read_register_bank(VB4H, inst.rm);
		
		sint32[4] rd = (sint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (sint32)rn[i] * (sint32)rm[i];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 3: {	// 8h:upper -> 4s
		sint16[8] rn = (sint16[8])read_register_bank(VB8H, inst.rn);
		sint16[8] rm = (sint16[8])read_register_bank(VB8H, inst.rm);
		
		sint32[4] rd = (sint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (sint32)rn[i+4] * (sint32)rm[i+4];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 4: {	// 2s -> 2d
		sint32[2] rn = (sint32[2])read_register_bank(VB2S, inst.rn);
		sint32[2] rm = (sint32[2])read_register_bank(VB2S, inst.rm);
		
		sint64[2] rd = (sint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (sint64)rn[i] * (sint64)rm[i];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	case 5: {	// 4s -> 2d
		sint32[4] rn = (sint32[4])read_register_bank(VB4S, inst.rn);
		sint32[4] rm = (sint32[4])read_register_bank(VB4S, inst.rm);
		
		sint64[2] rd = (sint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (sint64)rn[i+2] * (sint64)rm[i+2];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(umull)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		uint8[8] rm = read_register_bank(VB8B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (uint16)rn[i] * (uint16)rm[i];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		uint8[16] rm = read_register_bank(VB16B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (uint16)rn[i+8] * (uint16)rm[i+8];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 2: {	// 4h -> 4s
		uint16[4] rn = read_register_bank(VB4H, inst.rn);
		uint16[4] rm = read_register_bank(VB4H, inst.rm);
		
		uint32[4] rd = (uint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (uint32)rn[i] * (uint32)rm[i];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 3: {	// 8h:upper -> 4s
		uint16[8] rn = read_register_bank(VB8H, inst.rn);
		uint16[8] rm = read_register_bank(VB8H, inst.rm);
		
		uint32[4] rd = (uint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (uint32)rn[i+4] * (uint32)rm[i+4];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 4: {	// 2s -> 2d
		uint32[2] rn = read_register_bank(VB2S, inst.rn);
		uint32[2] rm = read_register_bank(VB2S, inst.rm);
		
		uint64[2] rd = (uint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (uint64)rn[i] * (uint64)rm[i];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	case 5: {	// 4s -> 2d
		uint32[4] rn = read_register_bank(VB4S, inst.rn);
		uint32[4] rm = read_register_bank(VB4S, inst.rm);
		
		uint64[2] rd = (uint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (uint64)rn[i+2] * (uint64)rm[i+2];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(saddl)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		sint8[8] rn = (sint8[8])read_register_bank(VB8B, inst.rn);
		sint8[8] rm = (sint8[8])read_register_bank(VB8B, inst.rm);
		
		sint16[8] rd = (sint16)0;
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (sint16)rn[i] + (sint16)rm[i];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		sint8[16] rn = (sint8[16])read_register_bank(VB16B, inst.rn);
		sint8[16] rm = (sint8[16])read_register_bank(VB16B, inst.rm);
		
		sint16[8] rd = (sint16)0;
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (sint16)rn[i+8] + (sint16)rm[i+8];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 2: {	// 4h -> 4s
		sint16[4] rn = (sint16[4])read_register_bank(VB4H, inst.rn);
		sint16[4] rm = (sint16[4])read_register_bank(VB4H, inst.rm);
		
		sint32[4] rd = (sint32)0;
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (sint32)rn[i] + (sint32)rm[i];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 3: {	// 8h:upper -> 4s
		sint16[8] rn = (sint16[8])read_register_bank(VB8H, inst.rn);
		sint16[8] rm = (sint16[8])read_register_bank(VB8H, inst.rm);
		
		sint32[4] rd = (sint32)0;
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (sint32)rn[i+4] + (sint32)rm[i+4];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 4: {	// 2s -> 2d
		sint32[2] rn = (sint32[2])read_register_bank(VB2S, inst.rn);
		sint32[2] rm = (sint32[2])read_register_bank(VB2S, inst.rm);
		
		sint64[2] rd = (sint64)0;
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (sint64)rn[i] + (sint64)rm[i];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	case 5: {	// 4s:upper -> 2d
		sint32[4] rn = (sint32[4])read_register_bank(VB4S, inst.rn);
		sint32[4] rm = (sint32[4])read_register_bank(VB4S, inst.rm);
		
		sint64[2] rd = (sint64)0;
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (sint64)rn[i+2] + (sint64)rm[i+2];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(uaddl)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		uint8[8] rn = (uint8[8])read_register_bank(VB8B, inst.rn);
		uint8[8] rm = (uint8[8])read_register_bank(VB8B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (uint16)rn[i] + (uint16)rm[i];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		uint8[16] rn = (uint8[16])read_register_bank(VB16B, inst.rn);
		uint8[16] rm = (uint8[16])read_register_bank(VB16B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (uint16)rn[i+8] + (uint16)rm[i+8];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 2: {	// 4h -> 4s
		uint16[4] rn = (uint16[4])read_register_bank(VB4H, inst.rn);
		uint16[4] rm = (uint16[4])read_register_bank(VB4H, inst.rm);
		
		uint32[4] rd = (uint32)0;
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (uint32)rn[i] + (uint32)rm[i];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 3: {	// 8h:upper -> 4s
		uint16[8] rn = (uint16[8])read_register_bank(VB8H, inst.rn);
		uint16[8] rm = (uint16[8])read_register_bank(VB8H, inst.rm);
		
		uint32[4] rd = (uint32)0;
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (uint32)rn[i+4] + (uint32)rm[i+4];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 4: {	// 2s -> 2d
		uint32[2] rn = (uint32[2])read_register_bank(VB2S, inst.rn);
		uint32[2] rm = (uint32[2])read_register_bank(VB2S, inst.rm);
		
		uint64[2] rd = (uint64)0;
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (uint64)rn[i] + (uint64)rm[i];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	case 5: {	// 4s:upper -> 2d
		uint32[4] rn = (uint32[4])read_register_bank(VB4S, inst.rn);
		uint32[4] rm = (uint32[4])read_register_bank(VB4S, inst.rm);
		
		uint64[2] rd = (uint64)0;
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (uint64)rn[i+2] + (uint64)rm[i+2];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(saddw)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		sint16[8] rn = (sint16[8])read_register_bank(VB8H, inst.rn);
		sint8[8] rm = (sint8[8])read_register_bank(VB8B, inst.rm);
		
		sint16[8] rd = (sint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = rn[i] + (sint16)rm[i];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		sint16[8] rn = (sint16[8])read_register_bank(VB8H, inst.rn);
		sint8[16] rm = (sint8[16])read_register_bank(VB16B, inst.rm);
		
		sint16[8] rd = (sint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = rn[i] + (sint16)rm[i+8];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 2: {	// 4h -> 4s
		sint32[4] rn = (sint32[4])read_register_bank(VB4S, inst.rn);
		sint16[4] rm = (sint16[4])read_register_bank(VB4H, inst.rm);
		
		sint32[4] rd = (sint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = rn[i] + (sint32)rm[i];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 3: {	// 8h:upper -> 4s
		sint32[4] rn = (sint32[4])read_register_bank(VB4S, inst.rn);
		sint16[8] rm = (sint16[8])read_register_bank(VB8H, inst.rm);
		
		sint32[4] rd = (sint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = rn[i] + (sint32)rm[i+4];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 4: {	// 2s -> 2d
		sint64[2] rn = (sint64[2])read_register_bank(VB2D, inst.rn);
		sint32[2] rm = (sint32[2])read_register_bank(VB2S, inst.rm);
		
		sint64[2] rd = (sint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = rn[i] + (sint64)rm[i];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	case 5: {	// 4s -> 2d
		sint64[2] rn = (sint64[2])read_register_bank(VB2D, inst.rn);
		sint32[4] rm = (sint32[4])read_register_bank(VB4S, inst.rm);
		
		sint64[2] rd = (sint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = rn[i] + (sint64)rm[i+2];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(uaddw)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		uint16[8] rn = (uint16[8])read_register_bank(VB8H, inst.rn);
		uint8[8] rm = (uint8[8])read_register_bank(VB8B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = rn[i] + (uint16)rm[i];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		uint16[8] rn = (uint16[8])read_register_bank(VB8H, inst.rn);
		uint8[16] rm = (uint8[16])read_register_bank(VB16B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = rn[i] + (uint16)rm[i+8];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 2: {	// 4h -> 4s
		uint32[4] rn = (uint32[4])read_register_bank(VB4S, inst.rn);
		uint16[4] rm = (uint16[4])read_register_bank(VB4H, inst.rm);
		
		uint32[4] rd = (uint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = rn[i] + (uint32)rm[i];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 3: {	// 8h:upper -> 4s
		uint32[4] rn = (uint32[4])read_register_bank(VB4S, inst.rn);
		uint16[8] rm = (uint16[8])read_register_bank(VB8H, inst.rm);
		
		uint32[4] rd = (uint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = rn[i] + (uint32)rm[i+4];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 4: {	// 2s -> 2d
		uint64[2] rn = (uint64[2])read_register_bank(VB2D, inst.rn);
		uint32[2] rm = (uint32[2])read_register_bank(VB2S, inst.rm);
		
		uint64[2] rd = (uint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = rn[i] + (uint64)rm[i];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	case 5: {	// 4s -> 2d
		uint64[2] rn = (uint64[2])read_register_bank(VB2D, inst.rn);
		uint32[4] rm = (uint32[4])read_register_bank(VB4S, inst.rm);
		
		uint64[2] rd = (uint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = rn[i] + (uint64)rm[i+2];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(ssubl)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		sint8[8] rn = (sint8[8])read_register_bank(VB8B, inst.rn);
		sint8[8] rm = (sint8[8])read_register_bank(VB8B, inst.rm);
		
		sint16[8] rd = (sint16)0;
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (sint16)rn[i] - (sint16)rm[i];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		sint8[16] rn = (sint8[16])read_register_bank(VB16B, inst.rn);
		sint8[16] rm = (sint8[16])read_register_bank(VB16B, inst.rm);
		
		sint16[8] rd = (sint16)0;
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (sint16)rn[i+8] - (sint16)rm[i+8];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 2: {	// 4h -> 4s
		sint16[4] rn = (sint16[4])read_register_bank(VB4H, inst.rn);
		sint16[4] rm = (sint16[4])read_register_bank(VB4H, inst.rm);
		
		sint32[4] rd = (sint32)0;
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (sint32)rn[i] - (sint32)rm[i];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 3: {	// 8h:upper -> 4s
		sint16[8] rn = (sint16[8])read_register_bank(VB8H, inst.rn);
		sint16[8] rm = (sint16[8])read_register_bank(VB8H, inst.rm);
		
		sint32[4] rd = (sint32)0;
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (sint32)rn[i+4] - (sint32)rm[i+4];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 4: {	// 2s -> 2d
		sint32[2] rn = (sint32[2])read_register_bank(VB2S, inst.rn);
		sint32[2] rm = (sint32[2])read_register_bank(VB2S, inst.rm);
		
		sint64[2] rd = (sint64)0;
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (sint64)rn[i] - (sint64)rm[i];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	case 5: {	// 4s:upper -> 2d
		sint32[4] rn = (sint32[4])read_register_bank(VB4S, inst.rn);
		sint32[4] rm = (sint32[4])read_register_bank(VB4S, inst.rm);
		
		sint64[2] rd = (sint64)0;
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (sint64)rn[i+2] - (sint64)rm[i+2];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(usubl)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		uint8[8] rn = (uint8[8])read_register_bank(VB8B, inst.rn);
		uint8[8] rm = (uint8[8])read_register_bank(VB8B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (uint16)rn[i] - (uint16)rm[i];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		uint8[16] rn = (uint8[16])read_register_bank(VB16B, inst.rn);
		uint8[16] rm = (uint8[16])read_register_bank(VB16B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = (uint16)rn[i+8] - (uint16)rm[i+8];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 2: {	// 4h -> 4s
		uint16[4] rn = (uint16[4])read_register_bank(VB4H, inst.rn);
		uint16[4] rm = (uint16[4])read_register_bank(VB4H, inst.rm);
		
		uint32[4] rd = (uint32)0;
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (uint32)rn[i] - (uint32)rm[i];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 3: {	// 8h:upper -> 4s
		uint16[8] rn = (uint16[8])read_register_bank(VB8H, inst.rn);
		uint16[8] rm = (uint16[8])read_register_bank(VB8H, inst.rm);
		
		uint32[4] rd = (uint32)0;
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = (uint32)rn[i+4] - (uint32)rm[i+4];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 4: {	// 2s -> 2d
		uint32[2] rn = (uint32[2])read_register_bank(VB2S, inst.rn);
		uint32[2] rm = (uint32[2])read_register_bank(VB2S, inst.rm);
		
		uint64[2] rd = (uint64)0;
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (uint64)rn[i] - (uint64)rm[i];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	case 5: {	// 4s:upper -> 2d
		uint32[4] rn = (uint32[4])read_register_bank(VB4S, inst.rn);
		uint32[4] rm = (uint32[4])read_register_bank(VB4S, inst.rm);
		
		uint64[2] rd = (uint64)0;
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = (uint64)rn[i+2] - (uint64)rm[i+2];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(ssubw)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		sint16[8] rn = (sint16[8])read_register_bank(VB8H, inst.rn);
		sint8[8] rm = (sint8[8])read_register_bank(VB8B, inst.rm);
		
		sint16[8] rd = (sint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = rn[i] - (sint16)rm[i];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		sint16[8] rn = (sint16[8])read_register_bank(VB8H, inst.rn);
		sint8[16] rm = (sint8[16])read_register_bank(VB16B, inst.rm);
		
		sint16[8] rd = (sint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = rn[i] - (sint16)rm[i+8];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 2: {	// 4h -> 4s
		sint32[4] rn = (sint32[4])read_register_bank(VB4S, inst.rn);
		sint16[4] rm = (sint16[4])read_register_bank(VB4H, inst.rm);
		
		sint32[4] rd = (sint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = rn[i] - (sint32)rm[i];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 3: {	// 8h:upper -> 4s
		sint32[4] rn = (sint32[4])read_register_bank(VB4S, inst.rn);
		sint16[8] rm = (sint16[8])read_register_bank(VB8H, inst.rm);
		
		sint32[4] rd = (sint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = rn[i] - (sint32)rm[i+4];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 4: {	// 2s -> 2d
		sint64[2] rn = (sint64[2])read_register_bank(VB2D, inst.rn);
		sint32[2] rm = (sint32[2])read_register_bank(VB2S, inst.rm);
		
		sint64[2] rd = (sint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = rn[i] - (sint64)rm[i];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	case 5: {	// 4s -> 2d
		sint64[2] rn = (sint64[2])read_register_bank(VB2D, inst.rn);
		sint32[4] rm = (sint32[4])read_register_bank(VB4S, inst.rm);
		
		sint64[2] rd = (sint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = rn[i] - (sint64)rm[i+2];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(usubw)
{
	switch (inst.tb) {
	case 0: {	// 8b -> 8h
		uint16[8] rn = (uint16[8])read_register_bank(VB8H, inst.rn);
		uint8[8] rm = (uint8[8])read_register_bank(VB8B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = rn[i] - (uint16)rm[i];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 1: {	// 16b:upper -> 8h
		uint16[8] rn = (uint16[8])read_register_bank(VB8H, inst.rn);
		uint8[16] rm = (uint8[16])read_register_bank(VB16B, inst.rm);
		
		uint16[8] rd = (uint16)0;
		
		for (uint8 i = 0; i < 8; i++) {
			rd[i] = rn[i] - (uint16)rm[i+8];
		}
		
		write_register_bank(VB8H, inst.rd, rd);
		break;
	}
	case 2: {	// 4h -> 4s
		uint32[4] rn = (uint32[4])read_register_bank(VB4S, inst.rn);
		uint16[4] rm = (uint16[4])read_register_bank(VB4H, inst.rm);
		
		uint32[4] rd = (uint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = rn[i] - (uint32)rm[i];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 3: {	// 8h:upper -> 4s
		uint32[4] rn = (uint32[4])read_register_bank(VB4S, inst.rn);
		uint16[8] rm = (uint16[8])read_register_bank(VB8H, inst.rm);
		
		uint32[4] rd = (uint32)0;
		
		for (uint8 i = 0; i < 4; i++) {
			rd[i] = rn[i] - (uint32)rm[i+4];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 4: {	// 2s -> 2d
		uint64[2] rn = (uint64[2])read_register_bank(VB2D, inst.rn);
		uint32[2] rm = (uint32[2])read_register_bank(VB2S, inst.rm);
		
		uint64[2] rd = (uint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = rn[i] - (uint64)rm[i];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	case 5: {	// 4s -> 2d
		uint64[2] rn = (uint64[2])read_register_bank(VB2D, inst.rn);
		uint32[4] rm = (uint32[4])read_register_bank(VB4S, inst.rm);
		
		uint64[2] rd = (uint64)0;
		
		for (uint8 i = 0; i < 2; i++) {
			rd[i] = rn[i] - (uint64)rm[i+2];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(neg_simd)
{
	if (inst.SCALAR == 1) {
		write_vector_reg64(inst.rd, (uint64)-(sint64)read_vector_reg64(inst.rn));
	} else {
		switch (inst.arrangement) {
		case 0: { // 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			write_register_bank(VB8B, inst.rd, -rn);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 1: { // 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			write_register_bank(VB16B, inst.rd, -rn);
			break;
		}
		case 2: { // 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			write_register_bank(VB4H, inst.rd, -rn);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 3: { // 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			write_register_bank(VB8H, inst.rd, -rn);
			break;
		}
		case 4: { // 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			write_register_bank(VB2S, inst.rd, -rn);
			write_register_bank(VBH, inst.rd, 0);
			break;
		}
		case 5: { // 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			write_register_bank(VB4S, inst.rd, -rn);
			break;
		}
		case 6: { // 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			write_register_bank(VB2D, inst.rd, -rn);
			break;
		}
		}
	}
}

execute(not_simd)
{
	if (inst.Q == 0) {
		write_vector_reg64(inst.rd, ~read_vector_reg64(inst.rn));
	} else {
		uint64 a;
		uint64 b;
		
		read_vector_reg128(inst.rn, a, b);
		write_vector_reg128(inst.rd, ~a, ~b);
	}
}

execute(ext)
{
	uint8[16] rn = read_register_bank(VB16B, inst.rn);
	uint8[16] rm = read_register_bank(VB16B, inst.rm);
	uint8[16] rd = (uint8)0;
	
	uint8 size = inst.Q == 0 ? 8 : 16;
	
	// Do RN
	uint8 o = 0;
	for (uint8 i = inst.imm4; i < size; i++) {
		rd[o++] = rn[i];
	}

	// Do RM
	for (uint8 j = 0; j < inst.imm4; j++) {
		rd[o++] = rm[j];
	}
	
	write_register_bank(VB16B, inst.rd, rd);
}

private helper float read_float_reg32(uint8 fr)
{
	return read_register_bank(FS, fr);
}

private helper double read_float_reg64(uint8 fr)
{
	return read_register_bank(FD, fr);
}

private helper void write_float_reg32(uint8 fr, float value)
{
	write_register_bank(FS, fr, value);
	write_register_bank(FSH, fr, 0);
	write_register_bank(VBH, fr, 0);
	return;
}

private helper void write_float_reg64(uint8 fr, double value)
{
	write_register_bank(FD, fr, value);
	write_register_bank(VBH, fr, 0);
	return;
}

private helper void write_vector_reg8(uint8 vr, uint8 value)
{
	write_register_bank(VBL, vr, (uint64)value);
	write_register_bank(VBH, vr, 0);
	return;
}

private helper void write_vector_reg16(uint8 vr, uint16 value)
{
	write_register_bank(VBL, vr, (uint64)value);
	write_register_bank(VBH, vr, 0);
	return;
}

private helper void write_vector_reg32(uint8 vr, uint32 value)
{
	write_register_bank(VBL, vr, (uint64)value);
	write_register_bank(VBH, vr, 0);
	return;
}

private helper void write_vector_reg64(uint8 vr, uint64 value)
{
	write_register_bank(VBL, vr, value);
	write_register_bank(VBH, vr, 0);
	return;
}

private helper void write_vector_reg128(uint8 vr, uint64 vl, uint64 vh)
{
	write_register_bank(VBL, vr, vl);
	write_register_bank(VBH, vr, vh);
	return;
}

private helper uint8 read_vector_reg8(uint8 vr)
{
	return read_register_bank(VB, vr);
}

private helper uint16 read_vector_reg16(uint8 vr)
{
	return read_register_bank(VH, vr);
}

private helper uint32 read_vector_reg32(uint8 vr)
{
	return read_register_bank(VS, vr);
}

private helper uint64 read_vector_reg64(uint8 vr)
{
	return read_register_bank(VD, vr);
}

private helper void read_vector_reg128(uint8 vr, uint64& vl, uint64& vh)
{
	vl = read_register_bank(VBL, vr);
	vh = read_register_bank(VBH, vr);
	return;
}

private helper uint32 vfp_expand_imm32(uint8 imm8)
{
	uint32 v = (uint32)imm8;

	uint32 sign = (v & 0x80) >> 7;
    uint32 exp = (!(v & 0x40)) << 7;
    exp |= (((v & 0x40) == 0) ? (uint32)0 : (uint32)0x7c);
    exp |= ((v & 0x30) >> 4);

    uint32 frac = (v & 0xf) << 19;
    return sign << 31 | exp << 23 | frac;
}

private helper uint64 vfp_expand_imm64(uint8 imm8)
{
	uint64 v = (uint64)imm8;

	uint64 sign = (v & 0x80) >> 7;
    uint64 exp = (!(v & 0x40)) << 10;
    exp |= (((v & 0x40) == 0) ? (uint64)0 : (uint64)0x3fc);
    exp |= ((v & 0x30) >> 4);

    uint64 frac = (v & 0xf) << 48;
    return sign << 63 | exp << 52 | frac;
}
